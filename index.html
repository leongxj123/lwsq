<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能学术助手</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: white;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }

        .header {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .header h3 {
            font-size: 12px;
            margin-bottom: 20px;
        }

        .header-buttons {
            position: static;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: -12px;
            margin-bottom: 16px;
            z-index: 2;
        }

        .header-button {
            background-color: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 4px;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .header-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .header-button svg {
            width: 14px;
            height: 14px;
        }

        .config-section {
            padding: 20px;
            background-color: #ecf0f1;
            border-bottom: 1px solid #bdc3c7;
        }

        .config-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .config-group label {
            font-weight: bold;
            min-width: 80px;
        }

        .config-group input,
        .config-group select {
            padding: 8px 12px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
        }

        .config-group input[type="text"] {
            flex: 1;
            min-width: 200px;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: #ffffff;
        }

        .message {
            margin-bottom: 20px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
            position: relative;
            transition: opacity 0.3s, transform 0.3s;
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message.deleting {
            opacity: 0.5;
            transform: translateX(20px);
        }

        .message.selected {
            outline: 2px solid #3498db;
            border-radius: 10px;
            padding: 5px;
            margin: -5px 0 15px 0;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background-color: #3498db;
        }

        .message.assistant .message-avatar {
            background-color: #2ecc71;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 12px;
            word-wrap: break-word;
            position: relative;
            direction: ltr;
            text-align: left;
            line-height: 1.5;
        }
        .message-content p {
            margin-bottom: 8px;
        }

        .message-content p:last-child {
            margin-bottom: 0;
        }

        .message-content code {
            background-color: rgba(0, 0, 0, 0.05);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }

        .message-content pre {
            background-color: rgba(0, 0, 0, 0.05);
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 8px 0;
        }

        .message-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .message-content ul,
        .message-content ol {
            padding-left: 20px;
            margin: 8px 0;
        }

        .message-content blockquote {
            border-left: 3px solid #ddd;
            padding-left: 10px;
            color: #666;
            margin: 8px 0;
        }

        .message-content.rtl {
            direction: rtl;
            text-align: right;
        }

        .message.user .message-content {
            background-color: #3498db;
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.assistant .message-content {
            background-color: #ecf0f1;
            color: #2c3e50;
            border-bottom-left-radius: 4px;
        }

        .delete-button {
            position: absolute;
            top: 0;
            right: auto;
            left: -30px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #e74c3c;
            color: white;
            border: none;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message.user .delete-button {
            left: auto;
            right: -30px;
        }

        .message:hover .delete-button {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .delete-button {
                top: -25px;
                left: 0;
            }

            .message.user .delete-button {
                left: auto;
                right: 0;
            }
        }

        .message-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .message-content.rtl .message-actions {
            right: auto;
            left: 5px;
        }

        .message:hover .message-actions {
            opacity: 1;
        }

        .action-btn {
            background-color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 3px;
            padding: 2px 5px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .action-btn:hover {
            background-color: rgba(255, 255, 255, 0.9);
        }

        .bulk-controls {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #2c3e50;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
            gap: 10px;
            align-items: center;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .bulk-controls.visible {
            display: flex;
        }

        .bulk-controls button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .bulk-controls .cancel-btn {
            background-color: #7f8c8d;
            color: white;
        }

        .bulk-controls .delete-btn {
            background-color: #e74c3c;
            color: white;
        }

        .copy-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .input-section {
            padding: 20px;
            background-color: #ecf0f1;
            border-top: 1px solid #bdc3c7;
            position: relative;
        }

        .input-group {
            display: flex;
            gap: 10px;
            position: relative;
            align-items: flex-end;
        }

        #messageInput {
            flex: 1;
            min-height: 38px;
            max-height: 150px;
            padding: 12px;
            border: 1px solid #bdc3c7;
            border-radius: 24px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
            resize: none;
            overflow-y: auto;
            font-family: inherit;
            line-height: 1.4;
        }

        #messageInput:focus {
            border-color: #3498db;
        }

        #sendButton {
            padding: 12px 24px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 24px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        #sendButton:hover {
            background-color: #2980b9;
        }

        #sendButton:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        #stopButton {
            padding: 12px 24px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 24px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            display: none;
        }

        #stopButton:hover {
            background-color: #c0392b;
        }

        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            margin-left: 10px;
        }

        .loading.active {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error-message {
            color: #e74c3c;
            padding: 10px;
            background-color: #fee;
            border-radius: 4px;
            margin-top: 10px;
        }

        .success-message {
            color: #27ae60;
            padding: 10px;
            background-color: #efe;
            border-radius: 4px;
            margin-top: 10px;
        }

        .advanced-settings {
            margin-top: 10px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
            display: none;
        }

        .advanced-toggle {
            cursor: pointer;
            color: #3498db;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
        }

        .language-settings {
            display: flex;
            align-items: center;
            margin-top: 10px;
            gap: 10px;
        }

        .confirm-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
        }

        .confirm-dialog.visible {
            opacity: 1;
            visibility: visible;
        }

        .dialog-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .dialog-title {
            font-size: 18px;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .dialog-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .dialog-buttons .cancel {
            background-color: #ecf0f1;
            color: #7f8c8d;
        }

        .dialog-buttons .confirm {
            background-color: #e74c3c;
            color: white;
        }

        .file-upload-container {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background-color: #f7f9fa;
            border-top: 1px solid #ddd;
            padding: 15px;
            display: none;
            box-shadow: 0 -3px 10px rgba(0, 0, 0, 0.1);
            z-index: 5;
        }

        .file-upload-container.active {
            display: block;
        }

        .file-drop-area {
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 10px;
            transition: all 0.3s;
            background-color: #f9f9f9;
        }

        .file-drop-area.dragging {
            border-color: #3498db;
            background-color: #e1f0fa;
        }

        .file-drop-area p {
            margin-bottom: 10px;
            color: #7f8c8d;
        }

        .file-upload-button {
            display: inline-block;
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .file-upload-button:hover {
            background-color: #2980b9;
        }

        .file-input {
            position: absolute;
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            z-index: -1;
        }

        .file-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .file-item {
            position: relative;
            width: 100px;
            height: 120px;
            border-radius: 8px;
            overflow: hidden;
            background-color: #f5f5f5;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }

        .file-thumbnail {
            height: 70px;
            background-color: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .file-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .file-thumbnail .file-icon {
            font-size: 30px;
            color: #7f8c8d;
        }

        .file-info {
            padding: 5px;
            font-size: 10px;
            text-align: center;
            word-break: break-all;
        }

        .file-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 10px;
        }

        .file-size {
            font-size: 9px;
            color: #7f8c8d;
        }

        .file-status {
            font-size: 9px;
            font-weight: bold;
        }

        .file-status.uploading {
            color: #f39c12;
        }

        .file-status.success {
            color: #27ae60;
        }

        .file-status.error {
            color: #e74c3c;
        }

        .file-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 18px;
            height: 18px;
            background-color: rgba(231, 76, 60, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .attachment-indicator {
            position: relative;
            left: auto;
            right: auto;
            top: auto;
            transform: none;
            color: #3498db;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            align-self: flex-end;
            margin-bottom: 4px;
        }

        .attachment-indicator.active {
            color: #2ecc71;
        }

        .file-upload-close {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background-color: rgba(0, 0, 0, 0.1);
            color: #7f8c8d;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .edit-button {
            position: absolute;
            top: 0;
            right: auto;
            left: 10px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #3498db;
            color: white;
            border: none;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message.user .edit-button {
            left: auto;
            right: 10px;
        }

        .resend-button {
            position: absolute;
            top: 30px;
            right: auto;
            left: 10px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #2ecc71;
            color: white;
            border: none;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message.user .resend-button {
            left: auto;
            right: 10px;
        }

        .message:hover .edit-button,
        .message:hover .resend-button {
            opacity: 1;
        }

        .message-timestamp {
            font-size: 10px;
            color: #7f8c8d;
            margin-top: 5px;
            text-align: right;
        }

        .message.user .message-timestamp {
            text-align: left;
        }

        @media (max-width: 768px) {
            .config-group {
                flex-direction: column;
                align-items: stretch;
            }

            .config-group label {
                min-width: auto;
            }

            .message-content {
                max-width: 85%;
            }

            .header h1 {
                font-size: 20px;
                padding-right: 100px;
            }

            .header-buttons {
                transform: scale(0.9) translateY(-50%);
            }

            .bulk-controls {
                width: 90%;
                justify-content: center;
                flex-wrap: wrap;
            }
        }

        @media (max-width: 480px) {
            .container {
                height: 100dvh;
                min-height: 0;
            }

            .config-section {
                padding: 6px 4px 6px 4px;
                font-size: 13px;
                max-height: 120px;
                overflow-y: auto;
            }

            .config-group {
                flex-direction: column;
                align-items: stretch;
                gap: 4px;
            }

            .config-group label {
                min-width: auto;
                font-size: 13px;
            }

            .advanced-settings {
                padding-top: 4px;
                margin-top: 4px;
                font-size: 12px;
            }

            .input-section {
                padding: 6px 4px;
            }

            .input-group {
                gap: 4px;
            }

            #messageInput {
                min-height: 32px;
                font-size: 14px;
                padding: 8px;
                border-radius: 18px;
            }

            #sendButton,
            #stopButton {
                padding: 8px 12px;
                font-size: 14px;
                border-radius: 18px;
            }

            .chat-container {
                padding: 8px 2px;
                min-height: 120px;
                max-height: calc(100dvh - 220px);
                
            }

            .message-content {
                max-width: 98%;
                padding: 8px;
                font-size: 14px;
            }

            .header h1 {
                font-size: 18px;
                padding-right: 0;
            }

            .header h3 {
                font-size: 12px;
            }

            .header-buttons {
                transform: none;
                margin-top: 4px;
                justify-content: center;
            }

            .bulk-controls {
                width: 98%;
                font-size: 13px;
                padding: 6px 4px;
            }

            .message-content img {
                max-width: 100% !important;
                height: auto !important;
                max-height: 180px !important;
                object-fit: contain !important;
            }

            .file-upload-container {
                padding: 6px 2px;
            }

            .file-item {
                width: 70px;
                height: 90px;
            }
        }

        .screen-capture-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.3);
            z-index: 10000;
            cursor: crosshair;
            user-select: none;
        }

        .selection-rectangle {
            position: absolute;
            border: 2px dashed #007bff;
            background: rgba(0, 123, 255, 0.1);
            pointer-events: none;
        }

        .capture-instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10001;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #e9ecef;
            cursor: pointer;
            user-select: none;
        }

        .panel-header h3 {
            margin: 0;
            font-size: 16px;
            color: #495057;
        }

        .toggle-btn {
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .toggle-btn.collapsed {
            transform: rotate(-90deg);
        }

        .panel-content {
            padding: 16px;
            max-height: 500px; 
            overflow-y: auto;
            transition: max-height 0.3s ease;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.3) transparent;
        }

        .panel-content.collapsed {
            max-height: 0;
            padding: 0 16px;
            overflow: hidden;
        }

        .panel-content {
            scroll-behavior: smooth; 
        }

        .panel-content::-webkit-scrollbar {
            width: 8px;
        }

        .panel-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .panel-content::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .panel-content::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        .scroll-indicator {
            display: none; 
        }

        .panel-content:hover .scroll-indicator {
            display: none;
        }

        .scroll-indicator.show {
            display: none;
        }

        .panel-content::after {
            display: none;
        }

        .panel-content.has-scroll::after {
            display: none;
        }

        .literature-tools {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .literature-sidebar .literature-tools {
            gap: 15px; 
        }

        .literature-sidebar .tool-group {
            background: #f8f9fa;
            padding: 12px; 
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .literature-sidebar .tool-group label {
            display: block;
            margin-bottom: 8px; 
            font-weight: bold;
            color: #495057;
            font-size: 13px; 
        }

        .literature-sidebar .lit-btn {
            font-size: 12px; 
            padding: 6px 10px; 
            margin: 2px; 
        }

        .tool-group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
        }

        .tool-group label {
            font-weight: 500;
            color: #495057;
            min-width: 120px;
            font-size: 14px;
        }

        .lit-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .lit-btn:hover {
            background: #0056b3;
        }

        .lit-btn:active {
            background: #004085;
        }

        @media (max-width: 768px) {
            .tool-group {
                flex-direction: column;
                align-items: flex-start;
            }

            .tool-group label {
                min-width: auto;
                margin-bottom: 4px;
            }

            .lit-btn {
                font-size: 11px;
                padding: 5px 10px;
            }
        }

        .pdf-viewer-container {
            position: fixed;
            top: 50px;
            left: calc(100vw - 60vw - 20px); 
            width: 60vw;
            height: 80vh;
            background: #fff;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            resize: none; 
            overflow: hidden;
            min-width: 300px;
            min-height: 200px;
            max-width: none; 
            max-height: none; 
            
            border: 2px solid #3498db;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }

        .pdf-resize-handle {
            position: absolute;
            background: transparent;
            z-index: 10;
        }

        .pdf-resize-handle.right {
            top: 0;
            right: -5px;
            width: 10px;
            height: 100%;
            cursor: ew-resize;
        }

        .pdf-resize-handle.bottom {
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 10px;
            cursor: ns-resize;
        }

        .pdf-resize-handle.corner {
            bottom: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            cursor: nw-resize;
            background: #3498db;
            border-radius: 0 0 8px 0;
            opacity: 0.7;
            transition: all 0.2s;
        }

        .pdf-resize-handle.corner:hover {
            opacity: 1;
            background: #2980b9;
            transform: scale(1.1);
        }

        .pdf-viewer-container.resizing {
            user-select: none;
            transition: none;
            border-color: #e74c3c;
        }

        .pdf-viewer-container.resizing .pdf-resize-handle.corner {
            opacity: 1;
            background: #e74c3c;
        }

        @supports (transform: translateZ(0)) {
            .pdf-viewer-container {
                transform: translateZ(0);
                will-change: transform;
            }
        }

        @supports (backdrop-filter: blur(10px)) {
            .pdf-viewer-container {
                backdrop-filter: blur(10px);
            }
        }

        @supports not (transform: translateZ(0)) {
            .pdf-viewer-container {
                
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            }
        }

        .pdf-viewer-container.active {
            display: flex;
        }

        .pdf-viewer-container.dragging {
            user-select: none;
        }

        .pdf-viewer-container.minimized {
            height: 50px !important;
            resize: none;
        }

        .pdf-viewer-container.minimized .pdf-viewer-content {
            display: none;
        }

        .pdf-viewer-container.minimized .pdf-controls-main {
            display: none;
        }

        .pdf-viewer-container.minimized .pdf-controls-secondary > *:not(#pdfCompactToggle):not(#pdfMoreOptions):not(#pdfCloseViewer) {
            display: none;
        }

        .pdf-viewer-container.minimized .pdf-more-options {
            position: static;
        }

        .pdf-viewer-container.minimized .pdf-viewer-header {
            border-radius: 6px;
        }

        .pdf-viewer-container.minimized .pdf-viewer-title {
            font-size: 14px;
        }

        .pdf-viewer-header::after {
            content: "拖拽移动 | 右下角调整大小";
            position: absolute;
            right: 120px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }

        .pdf-viewer-container.minimized .pdf-viewer-header::after {
            content: "双击还原";
        }

        .pdf-viewer-header {
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            cursor: move;
            user-select: none;
            border-radius: 6px 6px 0 0;
        }

        .pdf-viewer-header:hover {
            background: #34495e;
        }

        .pdf-viewer-title {
            font-size: 16px;
            font-weight: bold;
            margin: 0;
            flex: 1;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .pdf-viewer-controls {
            display: flex;
            align-items: stretch;
            gap: 8px;
            padding: 5px;
            min-height: 40px;
            overflow: hidden;
            flex-wrap: nowrap;
        }

        .pdf-controls-main {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
            overflow-x: auto;
            overflow-y: hidden;
            padding-right: 5px;
            
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }

        .pdf-controls-main::-webkit-scrollbar {
            height: 3px;
        }

        .pdf-controls-main::-webkit-scrollbar-track {
            background: transparent;
        }

        .pdf-controls-main::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        .pdf-controls-secondary {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-shrink: 0;
            padding-left: 5px;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
        }

        .pdf-control-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 3px 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
            white-space: nowrap;
            height: 32px;
            box-sizing: border-box;
        }

        .pdf-control-group:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .pdf-control-group > * {
            flex-shrink: 0;
        }

        .pdf-page-info, .pdf-zoom-input {
            font-size: 12px;
            min-width: 0;
            text-align: center;
        }

        .pdf-page-info input {
            width: 40px !important;
            font-size: 12px;
            padding: 1px 2px !important;
        }

        .pdf-more-options {
            position: relative;
        }

        .pdf-more-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000; 
            min-width: 160px;
            padding: 4px 0;
            margin-top: 2px;
        }

        .pdf-menu-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            color: #333;
        }

        .pdf-menu-item:hover {
            background: #f5f5f5;
        }

        .pdf-menu-divider {
            margin: 4px 0;
            border: none;
            border-top: 1px solid #eee;
        }

        .pdf-close-btn {
            background: #ff4757 !important;
            color: white !important;
        }

        .pdf-close-btn:hover {
            background: #ff3742 !important;
        }

        .pdf-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .pdf-panel-header h4 {
            margin: 0;
            color: #333;
            font-size: 16px;
        }

        .pdf-action-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .pdf-action-btn:hover {
            background: #0056b3;
        }

        .pdf-list-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .pdf-search-container {
            margin-bottom: 15px;
        }

        .pdf-search-input-group {
            display: flex;
            gap: 0;
        }

        .pdf-search-tips {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            line-height: 1.4;
        }

        .pdf-viewer-container.compact .pdf-controls-main {
            gap: 5px;
        }

        .pdf-viewer-container.compact .pdf-control-group {
            padding: 2px 4px;
            gap: 2px;
        }

        .pdf-viewer-container.compact .pdf-control-btn {
            padding: 3px 5px;
            font-size: 11px;
            min-width: 20px;
            height: 20px;
        }

        .pdf-viewer-container.compact .pdf-control-group:nth-child(n+3) {
            display: none; 
        }

        .pdf-viewer-container.compact input {
            font-size: 11px !important;
            height: 18px !important;
            width: 35px !important;
        }

        .pdf-compact-toggle {
            background: rgba(255, 255, 255, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
        }

        .pdf-compact-toggle.active {
            background: rgba(255, 255, 255, 0.3) !important;
        }

        .pdf-control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }

        .pdf-control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .pdf-control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pdf-page-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            min-width: 100px;
            text-align: center;
        }

        .pdf-zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .pdf-zoom-input {
            width: 60px;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }

        .pdf-viewer-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .pdf-canvas-container {
            flex: 1;
            overflow: auto;
            background: #f8f9fa;
            position: relative;
            cursor: grab; 
            
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        .pdf-canvas-container:active {
            cursor: grabbing; 
        }

        .pdf-canvas-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .pdf-canvas-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .pdf-canvas-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .pdf-canvas-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .pdf-canvas-wrapper {
            display: inline-block;
            min-width: 100%;
            min-height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        .pdf-canvas-content {
            display: inline-block;
            position: relative;
        }

        .pdf-canvas {
            border: 1px solid #dee2e6;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
            background: white;
            cursor: crosshair;
            display: block; 
            border-radius: 4px;
            transition: box-shadow 0.3s ease;
            
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .pdf-canvas:hover {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .pdf-canvas.loading {
            opacity: 0.7;
            filter: blur(1px);
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        .pdf-text-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0;
            line-height: 1.0;
            pointer-events: none;
            z-index: 2;
        }

        .pdf-text-layer.enabled {
            opacity: 0.01; 
            pointer-events: auto;
        }

        .pdf-text-layer span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .pdf-text-layer.enabled span {
            background: rgba(255, 255, 0, 0.05); 
        }

        .pdf-text-layer.enabled span:hover {
            background: rgba(0, 123, 255, 0.1); 
        }

        .pdf-text-layer.debug {
            opacity: 0.5 !important;
            background: rgba(255, 255, 0, 0.2);
        }

        .pdf-text-layer.debug span {
            color: red !important;
            background: rgba(255, 255, 0, 0.3) !important;
            border: 1px solid red;
        }

        .page-upload-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .page-upload-content {
            background: white;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .page-upload-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 20px 10px;
            border-bottom: 1px solid #eee;
        }

        .page-upload-header h3 {
            margin: 0;
            color: #333;
        }

        .page-upload-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .page-upload-close:hover {
            color: #666;
        }

        .page-upload-body {
            padding: 20px;
        }

        .page-upload-option {
            margin-bottom: 15px;
        }

        .page-upload-option label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
        }

        .page-upload-option input[type="radio"] {
            margin-right: 8px;
        }

        .page-range-input {
            margin-left: 24px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .page-range-input input[type="number"] {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            text-align: center;
        }

        .page-upload-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 10px 20px 20px;
            border-top: 1px solid #eee;
        }

        .page-upload-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .page-upload-cancel {
            background: #f5f5f5;
            color: #666;
        }

        .page-upload-cancel:hover {
            background: #e9e9e9;
        }

        .page-upload-confirm {
            background: #007bff;
            color: white;
        }

        .page-upload-confirm:hover {
            background: #0056b3;
        }

        .pdf-text-layer span::selection {
            background: rgba(0, 123, 255, 0.3) !important;
            color: inherit !important;
        }

        .pdf-text-layer span::-moz-selection {
            background: rgba(0, 123, 255, 0.3) !important;
            color: inherit !important;
        }

        .pdf-main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            height: 100%; 
        }

        .pdf-sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            height: 100%; 
            max-height: 100vh; 
            overflow: hidden; 
        }

        .pdf-sidebar-tabs {
            display: flex;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
        }

        .pdf-tab-btn {
            flex: 1;
            padding: 10px 5px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 2px solid transparent;
        }

        .pdf-tab-btn.active {
            background: #fff;
            border-bottom-color: #007bff;
            color: #007bff;
        }

        .pdf-tab-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0; 
        }

        .pdf-tab-panel {
            display: none !important;
            flex: 1;
            padding: 10px;
            box-sizing: border-box;
            min-height: 0;
            flex-direction: column;
            overflow: hidden;
        }

        .pdf-tab-panel.active {
            display: flex !important;
        }

        .pdf-search-container {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .pdf-search-container input {
            flex: 1;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .pdf-search-container button {
            padding: 5px 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .tab-pagination {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            flex-shrink: 0; 
        }

        .search-pagination {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .pagination-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            text-align: center;
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            gap: 5px;
            flex-wrap: wrap;
        }

        .pagination-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            color: #333;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            min-width: 30px;
            text-align: center;
            transition: all 0.2s;
        }

        .pagination-btn:hover {
            background: #f8f9fa;
            border-color: #007bff;
        }

        .pagination-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .pagination-btn.visited {
            background: #e9ecef;
            color: #6c757d;
            border-color: #ced4da;
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #pdfOutlineList,
        #pdfAnnotationsList,
        #pdfBookmarksList,
        #pdfSearchResultsList {
            overflow-y: auto !important;
            max-height: none !important;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.3) transparent;
        }

        #pdfOutlineList::-webkit-scrollbar,
        #pdfAnnotationsList::-webkit-scrollbar,
        #pdfBookmarksList::-webkit-scrollbar,
        #pdfSearchResultsList::-webkit-scrollbar {
            width: 6px;
        }

        #pdfOutlineList::-webkit-scrollbar-track,
        #pdfAnnotationsList::-webkit-scrollbar-track,
        #pdfBookmarksList::-webkit-scrollbar-track,
        #pdfSearchResultsList::-webkit-scrollbar-track {
            background: transparent;
        }

        #pdfOutlineList::-webkit-scrollbar-thumb,
        #pdfAnnotationsList::-webkit-scrollbar-thumb,
        #pdfBookmarksList::-webkit-scrollbar-thumb,
        #pdfSearchResultsList::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        #pdfOutlineList::-webkit-scrollbar-thumb:hover,
        #pdfAnnotationsList::-webkit-scrollbar-thumb:hover,
        #pdfBookmarksList::-webkit-scrollbar-thumb:hover,
        #pdfSearchResultsList::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.5);
        }

        .pdf-outline-item.visited,
        .pdf-annotation-item.visited,
        .pdf-search-result.visited {
            background: #f8f9fa !important;
            border-left: 3px solid #28a745 !important;
            opacity: 0.8;
        }

        .pdf-outline-item.visited:hover,
        .pdf-annotation-item.visited:hover,
        .pdf-search-result.visited:hover {
            background: #e9ecef !important;
            opacity: 1;
        }

        .pdf-outline-item.visited .item-title,
        .pdf-annotation-item.visited .item-title,
        .pdf-search-result.visited .item-title {
            color: #28a745 !important;
        }

        .pdf-outline-item.current,
        .pdf-annotation-item.current,
        .pdf-search-result.current {
            background: #e3f2fd !important;
            border-left: 3px solid #2196f3 !important;
            box-shadow: 0 2px 4px rgba(33, 150, 243, 0.2);
        }

        .pdf-outline-item.current .item-title,
        .pdf-annotation-item.current .item-title,
        .pdf-search-result.current .item-title {
            color: #2196f3 !important;
            font-weight: bold;
        }

        .pdf-outline-item {
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            margin: 2px 0;
        }

        .pdf-outline-item:hover {
            background: #e9ecef;
        }

        .pdf-outline-item.level-1 { margin-left: 0; }
        .pdf-outline-item.level-2 { margin-left: 15px; }
        .pdf-outline-item.level-3 { margin-left: 30px; }

        .pdf-annotation-item {
            padding: 8px;
            margin: 5px 0;
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            font-size: 12px;
        }

        .pdf-annotation-text {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .pdf-annotation-meta {
            color: #666;
            font-size: 11px;
        }

        .pdf-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .pdf-loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #e9ecef;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }

        .pdf-loading-overlay[style*="display: flex"] .pdf-loading-spinner {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .pdf-loading-text {
            color: #007bff;
            font-weight: 600;
            font-size: 16px;
            text-align: center;
            margin-bottom: 10px;
        }

        .pdf-loading-progress {
            width: 200px;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .pdf-loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .pdf-loading-overlay[style*="display: flex"] .pdf-loading-text.animated::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        .pdf-annotation-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .pdf-annotation-item:hover {
            background: #e9ecef;
        }

        .pdf-annotation-text {
            font-size: 14px;
            margin-bottom: 5px;
        }

        .pdf-annotation-page {
            font-size: 12px;
            color: #6c757d;
        }

        .pdf-selection-overlay {
            position: absolute;
            border: 2px dashed #007bff;
            background: rgba(0, 123, 255, 0.1);
            pointer-events: none;
            z-index: 10;
            display: none;
            top: 0;
            left: 0;
        }

        .literature-sidebar {
            position: fixed;
            top: 0;
            left: -320px; 
            width: 320px; 
            height: 100vh;
            background: #ffffff;
            border-right: 1px solid #dee2e6;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            transition: left 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .literature-sidebar.open {
            left: 0;
        }

        .literature-sidebar-header {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .literature-sidebar-header h3 {
            margin: 0;
            color: #333;
            font-size: 16px;
        }

        .sidebar-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
        }

        .sidebar-toggle:hover {
            background: #e9ecef;
            color: #495057;
            transform: scale(1.1);
        }

        .literature-sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px; 
        }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        @media (max-width: 768px) {
            .literature-sidebar {
                width: 85vw; 
                left: -85vw;
            }
        }

        @media (max-width: 1024px) and (min-width: 769px) {
            .literature-sidebar {
                width: 280px; 
                left: -280px;
            }
        }

        .literature-panel {
            display: none; 
        }

        .literature-panel.expanded {
            position: fixed;
            top: 50px;
            left: 20px;
            width: 380px; 
            max-height: calc(100vh - 100px);
            z-index: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
        }

        .literature-panel.expanded .panel-content {
            max-height: calc(100vh - 150px); 
            flex: 1;
            overflow-y: auto;
            min-height: 0; 
            padding-bottom: 20px; 
        }

        .file-upload-container.active {
            z-index: 200;
        }

        .highlight-yellow {
            background-color: #fff3cd !important;
            border-bottom: 2px solid #ffc107;
        }

        .highlight-green {
            background-color: #d4edda !important;
            border-bottom: 2px solid #28a745;
        }

        .highlight-blue {
            background-color: #cce5ff !important;
            border-bottom: 2px solid #007bff;
        }

        .highlight-pink {
            background-color: #f8d7da !important;
            border-bottom: 2px solid #dc3545;
        }

        .highlight-toolbar {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: none;
        }

        .highlight-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            margin: 0 2px;
            cursor: pointer;
            border: 1px solid #ccc;
        }

        .highlight-btn.yellow { background-color: #ffc107; }
        .highlight-btn.green { background-color: #28a745; }
        .highlight-btn.blue { background-color: #007bff; }
        .highlight-btn.pink { background-color: #dc3545; }
        .highlight-btn.remove { background-color: #6c757d; color: white; }

        .note-editor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            display: none;
        }

        .note-editor-header {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .note-editor-content {
            padding: 15px;
        }

        .note-editor textarea {
            width: 100%;
            min-height: 200px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            font-family: inherit;
            resize: vertical;
        }

        .note-editor-actions {
            padding: 15px;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .citation-format-selector {
            margin: 10px 0;
        }

        .citation-format-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .citation-output {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }

        @media (max-width: 768px) {
            .pdf-sidebar {
                width: 100%;
                position: absolute;
                top: 0;
                right: -100%;
                transition: right 0.3s ease;
                z-index: 10;
            }

            .pdf-sidebar.mobile-open {
                right: 0;
            }

            .pdf-viewer-controls {
                flex-wrap: wrap;
                gap: 5px;
            }

            .pdf-control-btn {
                padding: 6px 8px;
                font-size: 12px;
            }

            .pdf-page-info {
                min-width: 80px;
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    
    <div class="literature-sidebar" id="literatureSidebar">
        <div class="literature-sidebar-header">
            <h3>📚 文献阅读助手</h3>
            <button class="sidebar-toggle" id="literatureSidebarToggle" title="关闭文献助手">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 18px; height: 18px;">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="literature-sidebar-content" id="literatureSidebarContent">
            <div class="pdf-status-indicator" id="pdfStatusIndicator" style="font-size: 12px; color: #666; margin-bottom: 15px;">
                📄 未加载PDF
            </div>

            <div class="literature-tools">
                <div class="tool-group">
                    <label>文本分析:</label>
                    <button class="lit-btn" id="summarizeBtn" title="生成结构化摘要，包括背景、方法、发现、结论">智能摘要</button>
                    <button class="lit-btn" id="keyPointsBtn" title="提取并分类整理关键要点">关键要点</button>
                    <button class="lit-btn" id="keywordExtractBtn" title="提取核心概念和专业术语">关键词提取</button>
                </div>
                <div class="tool-group">
                    <label>深度分析:</label>
                    <button class="lit-btn" id="methodologyBtn" title="分析研究设计、数据收集和分析方法">方法论分析</button>
                    <button class="lit-btn" id="critiqueBtn" title="评估研究优势、局限性和改进建议">批判性评价</button>
                    <button class="lit-btn" id="questionsBtn" title="生成理解性、批判性和应用性问题">深度提问</button>
                </div>
                <div class="tool-group">
                    <label>学术写作:</label>
                    <button class="lit-btn" id="paraphraseBtn" title="学术化改写，适合论文引用">改写润色</button>
                    <button class="lit-btn" id="outlineBtn" title="基于文献生成相关主题论文大纲">论文大纲</button>
                    <button class="lit-btn" id="relatedWorkBtn" title="分析相关研究和研究现状">相关工作</button>
                </div>
                <div class="tool-group">
                    <label>研究工具:</label>
                    <button class="lit-btn" id="conceptMapBtn" title="生成知识结构和概念关系图谱">概念图谱</button>
                    <button class="lit-btn" id="researchQuestionsBtn" title="生成研究问题和研究方向">研究问题生成</button>
                    <button class="lit-btn" id="futureWorkBtn" title="分析未来研究方向和拓展机会">未来研究方向</button>
                </div>
                <div class="tool-group">
                    <label>PDF工具:</label>
                    <button class="lit-btn" id="pdfUploadBtn" title="上传PDF文件到预览器进行阅读和分析">上传PDF</button>
                    <input type="file" id="pdfFileInput" accept=".pdf" style="display: none;">
                    <button class="lit-btn" id="reopenPDFBtn" title="重新打开已加载的PDF预览器" style="display: none;">重新打开</button>
                    <button class="lit-btn" id="clearPDFBtn" title="清除当前PDF状态">清除PDF</button>
                    <button class="lit-btn" id="testPDFStatusBtn" title="检查当前PDF加载状态">测试PDF状态</button>
                </div>
            </div>
        </div>
    </div>

    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <div class="container">
        <div class="header">
            <h1>智能学术助手</h1>
            <h3>本站点仅用于团队项目研究，请勿外传，切勿上传或生成政治、保密、违法相关文件</h3>
            <div class="header-buttons">
                <button id="exportButton" class="header-button" title="导出对话">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M12 3v12M7 11l5 5 5-5M5 21h14"></path>
                    </svg>
                    导出
                </button>
                <button id="sidebarOpenBtn" class="header-button" title="打开文献阅读助手">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                        <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                    </svg>
                    <span id="sidebarBtnText">文献助手</span>
                </button>
                <button id="clearButton" class="header-button" title="清空聊天">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                    </svg>
                    清空
                </button>
            </div>
        </div>

        <div class="config-section">
            <div class="config-group" style="margin-bottom: 10px;">
                <label for="apiUrl">API地址:</label>
                <input type="text" id="apiUrl" placeholder="请输入API地址"
                    value="https://api.2023gpt.top/v1/chat/completions">
                <label for="apiKey">API Key:</label>
                <input type="text" id="apiKey" placeholder="请输入您的API Key">
            </div>
            <div class="config-group">
                <label for="modelSelect">模型:</label>
                <select id="modelSelect">
                    <option value="gpt-4o-all">GPT图文分析</option>
                    <option value="学术科研1">学术科研1</option>
                    <option value="学术科研3">学术科研2</option>
                    <option value="ResearchGPT">ResearchGPT</option>
                    <option value="Pubmed检索">Pubmed检索</option>
                    <option value="PubMed报告">PubMed报告</option>
                    <option value="绘图">绘图1</option>
                    <option value="flux">绘图2</option>
                    <option value="url-analysis">链接内容分析</option>
                    <option value="veo3-fast-frames">veo3</option>
                </select>
                <label for="tempSlider">温度:</label>
                <input type="range" id="tempSlider" min="0" max="2" step="0.1" value="0.7">
                <span id="tempValue">0.7</span>
                <label for="streamCheckbox">流式输出:</label>
                <input type="checkbox" id="streamCheckbox" checked>
            </div>
            <div class="advanced-toggle" id="advancedToggle">显示高级设置 ▼</div>
            <div class="advanced-settings" id="advancedSettings">
                <div class="language-settings">
                    <label for="textDirectionSelect">文字方向:</label>
                    <select id="textDirectionSelect">
                        <option value="ltr">从左到右</option>
                        <option value="rtl">从右到左</option>
                    </select>
                    <label for="maxTokens">最大Token:</label>
                    <input type="number" id="maxTokens" min="100" max="1000000" value="128000" style="width: 100px;">
                </div>
                <div class="config-group" style="margin-top: 10px;">
                    <label for="systemPrompt">系统提示:</label>
                    <input type="text" id="systemPrompt" placeholder="输入系统提示信息">
                </div>
                <div class="config-group" style="margin-top: 10px;">
                    <label for="contextLength">上下文长度:</label>
                    <input type="number" id="contextLength" min="1" max="50" value="10" style="width: 100px;">
                    <span id="contextLengthDesc">保留最近10条消息作为上下文</span>
                </div>
                <div style="margin-top: 10px;">
                    <label for="selectionModeCheckbox" style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="selectionModeCheckbox">
                        <span style="margin-left: 5px;">启用批量选择模式</span>
                    </label>
                </div>
            </div>
            <div id="statusMessage"></div>
        </div>

        <div class="chat-container" id="chatContainer">
            
        </div>

        <div class="literature-panel" id="literaturePanel">
            <div class="panel-header" id="toggleLiteraturePanel">
                <h3>文献阅读助手</h3>
                <div class="pdf-status-indicator" id="pdfStatusIndicator" style="font-size: 12px; color: #666; margin-right: 10px;">
                    📄 未加载PDF
                </div>
                <button class="toggle-btn" id="literaturePanelToggle">▼</button>
            </div>
            <div class="panel-content" id="literaturePanelContent">
                <div class="scroll-indicator" id="literatureScrollIndicator">↓ 向下滚动查看更多</div>
                <div class="literature-tools">
                    <div class="tool-group">
                        <label>文本分析:</label>
                        <button class="lit-btn" id="summarizeBtn" title="生成结构化摘要，包括背景、方法、发现、结论">智能摘要</button>
                        <button class="lit-btn" id="keyPointsBtn" title="提取并分类整理关键要点">关键要点</button>
                        <button class="lit-btn" id="keywordExtractBtn" title="提取核心概念和专业术语">关键词提取</button>
                    </div>
                    <div class="tool-group">
                        <label>深度分析:</label>
                        <button class="lit-btn" id="methodologyBtn" title="分析研究设计、数据收集和分析方法">方法论分析</button>
                        <button class="lit-btn" id="critiqueBtn" title="评估研究优势、局限性和改进建议">批判性评价</button>
                        <button class="lit-btn" id="questionsBtn" title="生成理解性、批判性和应用性问题">深度提问</button>
                    </div>
                    <div class="tool-group">
                        <label>学术写作:</label>
                        <button class="lit-btn" id="paraphraseBtn" title="学术化改写，适合论文引用">改写润色</button>
                        <button class="lit-btn" id="outlineBtn" title="基于文献生成相关主题论文大纲">论文大纲</button>
                        <button class="lit-btn" id="relatedWorkBtn" title="分析相关研究和研究现状">相关工作</button>
                    </div>
                    <div class="tool-group">
                        <label>研究工具:</label>
                        <button class="lit-btn" id="conceptMapBtn" title="生成知识结构和概念关系图谱">概念图谱</button>
                        <button class="lit-btn" id="researchQuestionsBtn" title="生成研究问题和研究方向">研究问题生成</button>
                        <button class="lit-btn" id="futureWorkBtn" title="分析未来研究方向和拓展机会">未来研究方向</button>
                    </div>
                    <div class="tool-group">
                        <label>PDF工具:</label>
                        <button class="lit-btn" id="pdfUploadBtn" title="上传PDF文件到预览器进行阅读和分析">上传PDF</button>
                        <input type="file" id="pdfFileInput" accept=".pdf" style="display: none;">
                        <button class="lit-btn" id="reopenPDFBtn" title="重新打开已加载的PDF预览器" style="display: none;">重新打开</button>
                        <button class="lit-btn" id="clearPDFBtn" title="清除当前PDF状态">清除PDF</button>
                        <button class="lit-btn" id="testPDFStatusBtn" title="检查当前PDF加载状态">测试PDF状态</button>

                        <button class="lit-btn" id="expandPanelBtn" title="展开/收起文献助手面板">展开面板</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="bulk-controls" id="bulkControls">
            <span id="selectedCount">已选择 0 条消息</span>
            <button class="cancel-btn" id="cancelSelectButton">取消</button>
            <button class="delete-btn" id="bulkDeleteButton">删除选中</button>
        </div>

        <div class="input-section">
            
            <div class="file-upload-container" id="fileUploadContainer">
                <button class="file-upload-close" id="fileUploadClose">×</button>
                <div class="file-drop-area" id="fileDropArea">
                    <p>拖放文件到此处，或点击下方按钮选择文件</p>
                    <label for="fileInput" class="file-upload-button">选择文件</label>
                    <input type="file" id="fileInput" class="file-input" multiple>
                </div>
                <div class="file-preview" id="filePreview"></div>
            </div>

            <div class="input-group">
                <div class="attachment-indicator" id="attachmentIndicator" title="附件">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                        <path
                            d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48">
                        </path>
                    </svg>
                </div>
                
                <textarea id="messageInput" placeholder="输入您的消息..." autofocus></textarea>
                <button id="sendButton">发送</button>
                <button id="stopButton">停止</button>
            </div>
        </div>
    </div>

    <div class="copy-toast" id="copyToast">复制成功</div>

    <div class="pdf-viewer-container" id="pdfViewerContainer">
        
        <div class="pdf-resize-handle right" id="pdfResizeRight"></div>
        <div class="pdf-resize-handle bottom" id="pdfResizeBottom"></div>
        <div class="pdf-resize-handle corner" id="pdfResizeCorner" title="拖拽调整大小"></div>

        <div class="pdf-viewer-header" id="pdfViewerHeader">
            <h3 class="pdf-viewer-title" id="pdfViewerTitle">PDF 预览</h3>
            <div class="pdf-viewer-controls">
                
                <div class="pdf-controls-main">
                    
                    <div class="pdf-control-group">
                        <button class="pdf-control-btn" id="pdfPrevPage" title="上一页 (←)">◀</button>
                        <div class="pdf-page-info">
                            <input type="number" id="pdfPageInput" min="1" value="1"
                                   style="width: 40px; text-align: center; border: 1px solid #ccc; border-radius: 3px; padding: 1px 2px; font-size: 12px; height: 20px; box-sizing: border-box;">
                            / <span id="pdfTotalPages">1</span>
                        </div>
                        <button class="pdf-control-btn" id="pdfNextPage" title="下一页 (→)">▶</button>
                    </div>

                    <div class="pdf-control-group">
                        <button class="pdf-control-btn" id="pdfZoomOut" title="缩小 (Ctrl + 滚轮)">−</button>
                        <input type="text" class="pdf-zoom-input" id="pdfZoomLevel" value="100%" readonly
                               style="width: 50px; text-align: center; border: 1px solid #ccc; border-radius: 3px; padding: 2px; font-size: 12px; height: 20px; box-sizing: border-box;">
                        <button class="pdf-control-btn" id="pdfZoomIn" title="放大 (Ctrl + 滚轮)">+</button>
                        <button class="pdf-control-btn" id="pdfFitWidth" title="适应宽度">📐</button>
                        <button class="pdf-control-btn" id="pdfFitPage" title="适应页面">📄</button>
                        <button class="pdf-control-btn" id="pdfRotateLeft" title="逆时针旋转90度">↺</button>
                        <button class="pdf-control-btn" id="pdfRotateRight" title="顺时针旋转90度">↻</button>
                        <button class="pdf-control-btn" id="pdfResetRotation" title="重置旋转">🔄</button>
                    </div>

                    <div class="pdf-control-group">
                        <button class="pdf-control-btn" id="pdfTextSelect" title="文本选择模式">📝</button>
                        <button class="pdf-control-btn" id="pdfScreenshot" title="截图模式">📷</button>
                        <button class="pdf-control-btn" id="pdfHighlight" title="高亮选中文本">🖍️</button>
                    </div>

                    <div class="pdf-control-group">
                        <input type="url" id="pdfUrlInput" placeholder="输入PDF或网页URL..."
                               style="width: 150px; padding: 2px 4px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px; height: 20px; box-sizing: border-box; z-index: 10; position: relative;">
                        <button class="pdf-control-btn" id="pdfLoadUrl" title="加载URL">🌐</button>
                    </div>
                </div>

                <div class="pdf-controls-secondary">
                    <button class="pdf-control-btn pdf-compact-toggle" id="pdfCompactToggle" title="紧凑模式">⚡</button>
                    <button class="pdf-control-btn" id="pdfToggleSidebar" title="切换侧边栏">📋</button>
                    <button class="pdf-control-btn" id="pdfUploadPage" title="上传页面">📤</button>
                    <button class="pdf-control-btn" id="pdfDownload" title="下载PDF">💾</button>

                    <div class="pdf-more-options">
                        <button class="pdf-control-btn" id="pdfMoreOptions" title="更多选项">⋯</button>
                        <div class="pdf-more-menu" id="pdfMoreMenu" style="display: none;">
                            <button class="pdf-menu-item" id="pdfOutline">📑 显示目录</button>
                            <button class="pdf-menu-item" id="pdfDebugText">🔍 调试模式</button>
                            <button class="pdf-menu-item" id="pdfHelp">❓ 快捷键帮助</button>
                            <hr class="pdf-menu-divider">
                            <button class="pdf-menu-item" id="pdfResizeToggle">📏 切换大小</button>
                            <button class="pdf-menu-item" id="pdfMinimize">− 最小化</button>
                        </div>
                    </div>

                    <button class="pdf-control-btn pdf-close-btn" id="pdfCloseViewer" title="关闭">✕</button>
                </div>
            </div>
        </div>

        <div class="pdf-viewer-content">
            <div class="pdf-main-content">
                <div class="pdf-sidebar" id="pdfSidebar" style="display: none;">
                    <div class="pdf-sidebar-tabs">
                        <button class="pdf-tab-btn active" data-tab="outline">📑 目录</button>
                        <button class="pdf-tab-btn" data-tab="annotations">🖍️ 注释</button>
                        <button class="pdf-tab-btn" data-tab="bookmarks">🔖 书签</button>
                        <button class="pdf-tab-btn" data-tab="search">🔍 搜索</button>
                    </div>
                    <div class="pdf-tab-content">
                        <div class="pdf-tab-panel active" id="pdfOutlinePanel">
                            <div id="pdfOutlineList" style="flex: 1; overflow-y: auto; min-height: 0;">正在加载目录...</div>
                            <div class="tab-pagination" id="outlinePagination" style="display: none; flex-shrink: 0;">
                                <div class="pagination-info" id="outlinePaginationInfo"></div>
                                <div class="pagination-controls" id="outlinePaginationControls"></div>
                            </div>
                        </div>
                        <div class="pdf-tab-panel" id="pdfAnnotationsPanel">
                            <div id="pdfAnnotationsList" style="flex: 1; overflow-y: auto; min-height: 0;">暂无注释</div>
                            <button class="lit-btn" id="pdfAddNote" style="width: 100%; margin-top: 10px; font-size: 12px; flex-shrink: 0;">添加笔记</button>
                            <div class="tab-pagination" id="annotationsPagination" style="display: none; flex-shrink: 0;">
                                <div class="pagination-info" id="annotationsPaginationInfo"></div>
                                <div class="pagination-controls" id="annotationsPaginationControls"></div>
                            </div>
                        </div>
                        <div class="pdf-tab-panel" id="pdfBookmarksPanel">
                            <div id="pdfBookmarksList" style="flex: 1; overflow-y: auto; min-height: 0;">暂无书签</div>
                            <button class="lit-btn" id="pdfAddBookmark" style="width: 100%; margin-top: 10px; font-size: 12px; flex-shrink: 0;">添加书签</button>
                            <div class="tab-pagination" id="bookmarksPagination" style="display: none; flex-shrink: 0;">
                                <div class="pagination-info" id="bookmarksPaginationInfo"></div>
                                <div class="pagination-controls" id="bookmarksPaginationControls"></div>
                            </div>
                        </div>
                        <div class="pdf-tab-panel" id="pdfSearchPanel">
                            <div class="pdf-search-container" style="flex-shrink: 0;">
                                <input type="text" id="pdfSidebarSearch" placeholder="搜索PDF内容...">
                                <button id="pdfSidebarSearchBtn">搜索</button>
                            </div>
                            <div id="pdfSearchResultsList" style="flex: 1; overflow-y: auto; min-height: 0;">输入关键词开始搜索</div>
                            <div class="tab-pagination" id="searchPagination" style="display: none; flex-shrink: 0;">
                                <div class="pagination-info" id="searchPaginationInfo"></div>
                                <div class="pagination-controls" id="searchPaginationControls"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="pdf-canvas-container" id="pdfCanvasContainer">
                    <div class="pdf-canvas-wrapper" id="pdfCanvasWrapper">
                        <div class="pdf-canvas-content" id="pdfCanvasContent">
                            <canvas id="pdfCanvas" class="pdf-canvas"></canvas>
                            <div class="pdf-text-layer" id="pdfTextLayer"></div>
                            <div class="pdf-selection-overlay" id="pdfSelectionOverlay"></div>
                        </div>
                    </div>
                    <div class="pdf-loading-overlay" id="pdfLoadingOverlay" style="display: none;">
                        <div class="pdf-loading-spinner"></div>
                        <div class="pdf-loading-text animated" id="pdfLoadingText">正在加载PDF</div>
                        <div class="pdf-loading-progress" id="pdfLoadingProgress" style="display: none;">
                            <div class="pdf-loading-progress-bar" id="pdfLoadingProgressBar"></div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div class="confirm-dialog" id="confirmDialog">
        <div class="dialog-content">
            <div class="dialog-title" id="dialogTitle">确认操作</div>
            <div id="dialogMessage">确定要执行此操作吗？</div>
            <div class="dialog-buttons">
                <button class="cancel" id="dialogCancel">取消</button>
                <button class="confirm" id="dialogConfirm">确认</button>
            </div>
        </div>
    </div>

    <div class="highlight-toolbar" id="highlightToolbar">
        <button class="highlight-btn yellow" id="highlightYellow" title="黄色高亮"></button>
        <button class="highlight-btn green" id="highlightGreen" title="绿色高亮"></button>
        <button class="highlight-btn blue" id="highlightBlue" title="蓝色高亮"></button>
        <button class="highlight-btn pink" id="highlightPink" title="粉色高亮"></button>
        <button class="highlight-btn remove" id="removeHighlight" title="移除高亮">×</button>
    </div>

    <div id="pageUploadDialog" class="page-upload-dialog" style="display: none;">
        <div class="page-upload-content">
            <div class="page-upload-header">
                <h3>上传PDF页面</h3>
                <button class="page-upload-close" onclick="closePageUploadDialog()">×</button>
            </div>
            <div class="page-upload-body">
                <div class="page-upload-option">
                    <label>
                        <input type="radio" name="uploadType" value="current" checked>
                        上传当前页面 (第 <span id="currentPageNum">1</span> 页)
                    </label>
                </div>
                <div class="page-upload-option">
                    <label>
                        <input type="radio" name="uploadType" value="range">
                        上传页面范围
                    </label>
                    <div class="page-range-input" style="margin-top: 10px;">
                        从第 <input type="number" id="startPage" min="1" value="1" style="width: 60px;"> 页
                        到第 <input type="number" id="endPage" min="1" value="1" style="width: 60px;"> 页
                        <span style="color: #666; font-size: 12px;">(共 <span id="totalPageNum">1</span> 页)</span>
                    </div>
                </div>

                <div class="page-upload-format" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                    <div style="margin-bottom: 10px; font-weight: bold; color: #333;">输出格式:</div>
                    <div class="page-upload-option">
                        <label>
                            <input type="radio" name="outputFormat" value="pdf" checked>
                            PDF格式 (推荐，保持原始质量)
                        </label>
                    </div>
                    <div class="page-upload-option">
                        <label>
                            <input type="radio" name="outputFormat" value="image">
                            图片格式 (PNG，适合截图)
                        </label>
                    </div>
                </div>

                <div class="page-upload-actions" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                    <div style="margin-bottom: 10px; font-weight: bold; color: #333;">处理方式:</div>
                    <div class="page-upload-option">
                        <label>
                            <input type="checkbox" id="uploadPagesToChat" checked>
                            添加到聊天对话中
                        </label>
                    </div>
                    <div class="page-upload-option">
                        <label>
                            <input type="checkbox" id="savePagesToLocal" checked>
                            保存到本地下载
                        </label>
                    </div>
                </div>
            </div>
            <div class="page-upload-footer">
                <button class="page-upload-btn page-upload-cancel" onclick="closePageUploadDialog()">取消</button>
                <button class="page-upload-btn page-upload-confirm" onclick="confirmPageUpload()">确认处理</button>
            </div>
        </div>
    </div>

    <div id="screenshotOptionsDialog" class="page-upload-dialog" style="display: none;">
        <div class="page-upload-content">
            <div class="page-upload-header">
                <h3>截图选项</h3>
                <button class="page-upload-close" onclick="closeScreenshotOptionsDialog()">×</button>
            </div>
            <div class="page-upload-body">
                <div style="margin-bottom: 15px; color: #666;">
                    选择截图的处理方式：
                </div>
                <div class="page-upload-option">
                    <label>
                        <input type="checkbox" id="uploadToChat" checked>
                        添加到聊天对话中
                    </label>
                </div>
                <div class="page-upload-option">
                    <label>
                        <input type="checkbox" id="saveToLocal" checked>
                        保存到本地下载
                    </label>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                    <div style="margin-bottom: 10px; font-weight: bold; color: #333;">文件名:</div>
                    <input type="text" id="screenshotFileName" placeholder="截图文件名"
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        不包含扩展名，将自动添加.png
                    </div>
                </div>
            </div>
            <div class="page-upload-footer">
                <button class="page-upload-btn page-upload-cancel" onclick="closeScreenshotOptionsDialog()">取消</button>
                <button class="page-upload-btn page-upload-confirm" onclick="confirmScreenshotOptions()">确认</button>
            </div>
        </div>
    </div>

    <div class="note-editor" id="noteEditor">
        <div class="note-editor-header">
            <h4>添加笔记</h4>
            <button class="pdf-control-btn" id="closeNoteEditor">×</button>
        </div>
        <div class="note-editor-content">
            <div style="margin-bottom: 10px;">
                <label for="noteTitle">笔记标题:</label>
                <input type="text" id="noteTitle" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 5px;">
            </div>
            <div style="margin-bottom: 10px;">
                <label for="noteContent">笔记内容:</label>
                <textarea id="noteContent" placeholder="在此输入您的笔记内容..."></textarea>
            </div>
            <div style="margin-bottom: 10px;">
                <label for="noteTags">标签 (用逗号分隔):</label>
                <input type="text" id="noteTags" placeholder="例如: 重要, 方法论, 结论" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 5px;">
            </div>
        </div>
        <div class="note-editor-actions">
            <button class="pdf-control-btn" id="cancelNote">取消</button>
            <button class="pdf-control-btn" id="saveNote" style="background: #28a745;">保存</button>
        </div>
    </div>
    </div> 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <script>

        let conversationHistory = [];
        let isGenerating = false;
        let selectionMode = false;
        let selectedMessages = new Set();
        let messageElements = new Map();
        let messageCounter = 0;
        let abortController = null;
        let uploadedFiles = [];
        let uploadedFileUrls = [];
        let currentEditingMessageId = null;

        let isCapturing = false;
        let captureOverlay = null;
        let selectionRect = null;
        let startX, startY, endX, endY;

        let literaturePanelCollapsed = false;

        let currentPDF = null;
        let currentPDFFile = null;
        let currentPDFFileName = '';
        let currentPage = 1;
        let totalPages = 0;
        let currentScale = 1.0;
        let pdfContext = null;
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };

        const PDFState = {
            IDLE: 'idle',
            LOADING: 'loading',
            RENDERING: 'rendering',
            ERROR: 'error',
            READY: 'ready'
        };

        let currentPDFState = PDFState.IDLE;
        let pdfLoadingProgress = 0;
        let renderQueue = [];
        let isRenderingInProgress = false;
        let pdfAnnotations = [];
        let pdfBookmarks = [];
        let pdfSearchResultsData = [];
        let isScreenshotMode = false;
        let isTextSelectionMode = false;
        let selectedText = '';

        const itemsPerPage = 10;

        const paginationStates = {
            outline: { currentPage: 1, totalPages: 0, visitedPages: new Set(), data: [] },
            annotations: { currentPage: 1, totalPages: 0, visitedPages: new Set(), data: [] },
            bookmarks: { currentPage: 1, totalPages: 0, visitedPages: new Set(), data: [] },
            search: { currentPage: 1, totalPages: 0, visitedPages: new Set(), data: [], searchTerm: '' }
        };

        const visitedItems = {
            outline: new Set(),
            annotations: new Set(),
            bookmarks: new Set(),
            search: new Set()
        };

        let currentViewingPage = 1;

        const HardwareCapabilities = {
            hasGPU: false,
            hasWebGL: false,
            hasHardwareAcceleration: false,

            detect: function() {

                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    this.hasWebGL = !!gl;

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            this.hasGPU = !renderer.toLowerCase().includes('software');
                        }
                    }
                } catch (e) {
                    this.hasWebGL = false;
                    this.hasGPU = false;
                }

                this.hasHardwareAcceleration = CSS.supports('transform', 'translateZ(0)');

                console.log('硬件能力检测结果:', {
                    hasGPU: this.hasGPU,
                    hasWebGL: this.hasWebGL,
                    hasHardwareAcceleration: this.hasHardwareAcceleration
                });

                return this;
            },

            getOptimalRenderSettings: function() {
                if (this.hasGPU && this.hasWebGL) {
                    return {
                        enableWebGL: true,
                        maxScale: 10.0,
                        renderQuality: 'high',
                        useHardwareAcceleration: true
                    };
                } else if (this.hasHardwareAcceleration) {
                    return {
                        enableWebGL: false,
                        maxScale: 5.0,
                        renderQuality: 'medium',
                        useHardwareAcceleration: true
                    };
                } else {
                    return {
                        enableWebGL: false,
                        maxScale: 3.0,
                        renderQuality: 'low',
                        useHardwareAcceleration: false
                    };
                }
            }
        };

        function setPDFState(newState, progress = 0) {
            currentPDFState = newState;
            pdfLoadingProgress = progress;

            const loadingOverlay = document.getElementById('pdfLoadingOverlay');
            const loadingText = document.getElementById('pdfLoadingText');
            const loadingProgress = document.getElementById('pdfLoadingProgress');
            const loadingProgressBar = document.getElementById('pdfLoadingProgressBar');
            const canvas = document.getElementById('pdfCanvas');

            switch (newState) {
                case PDFState.LOADING:
                    if (loadingOverlay) loadingOverlay.style.display = 'flex';
                    if (loadingText) loadingText.textContent = '正在加载PDF';
                    if (loadingProgress) loadingProgress.style.display = 'block';
                    if (canvas) canvas.classList.add('loading');
                    break;

                case PDFState.RENDERING:
                    if (loadingText) loadingText.textContent = '正在渲染页面';
                    if (canvas) canvas.classList.add('loading');
                    break;

                case PDFState.READY:
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                    if (canvas) canvas.classList.remove('loading');
                    break;

                case PDFState.ERROR:
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                    if (canvas) canvas.classList.remove('loading');
                    break;

                case PDFState.IDLE:
                default:
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                    if (canvas) canvas.classList.remove('loading');
                    break;
            }

            if (loadingProgressBar && progress > 0) {
                loadingProgressBar.style.width = progress + '%';
            }
        }

        function logPDFStatus(location) {
            console.log('[' + location + '] PDF状态:', {
                currentPDF: !!currentPDF,
                currentPDFFile: !!currentPDFFile,
                currentPDFFileName,
                totalPages,
                currentState: currentPDFState,
                progress: pdfLoadingProgress,
                viewerActive: pdfViewerContainer ? pdfViewerContainer.classList.contains('active') : false
            });
        }

        function updatePDFStatusIndicator() {
            if (!pdfStatusIndicator) return;

            const isPDFLoaded = currentPDF && totalPages > 0 && currentPDFFile;
            const isViewerOpen = pdfViewerContainer && pdfViewerContainer.classList.contains('active');

            if (isPDFLoaded) {
                const fileSize = (currentPDFFile.size / 1024 / 1024).toFixed(1);
                let status = isViewerOpen ? '🔍 预览中' : '📋 已加载';
                if (isScreenshotMode) status += ' 📷';
                if (isTextSelectionMode && !isScreenshotMode) status += ' 📝';

                pdfStatusIndicator.innerHTML = status + ' ' + currentPDFFileName + ' (' + totalPages + '页, ' + fileSize + 'MB)';
                pdfStatusIndicator.style.color = isViewerOpen ? '#007bff' : '#28a745';

                let tooltipText = 'PDF状态: ' + (isViewerOpen ? '预览器已打开' : '预览器已关闭，但可用于分析') + '\n文件: ' + currentPDFFileName + '\n页数: ' + totalPages + '\n大小: ' + fileSize + 'MB\n\n快捷键:\n• Ctrl+M: 最小化/还原\n• Ctrl+R: 调整大小\n• Ctrl+F: 搜索\n• S: 截图模式\n• T: 文本选择\n• H: 高亮文本\n• ←→↑↓: 翻页\n• Esc: 退出模式';
                if (isScreenshotMode) tooltipText += '\n\n📷 截图模式已激活';
                if (isTextSelectionMode && !isScreenshotMode) tooltipText += '\n\n📝 文本选择模式已激活';

                pdfStatusIndicator.title = tooltipText;

                if (reopenPDFBtn) {
                    reopenPDFBtn.style.display = isViewerOpen ? 'none' : 'inline-block';
                }
            } else {
                pdfStatusIndicator.innerHTML = '📄 未加载PDF';
                pdfStatusIndicator.style.color = '#666';
                pdfStatusIndicator.title = '请上传PDF文件以使用分析功能';

                if (reopenPDFBtn) {
                    reopenPDFBtn.style.display = 'none';
                }
            }
        }

        const screenCaptureButton = document.getElementById('screenCaptureButton');
        const literaturePanel = document.getElementById('literaturePanel');
        const toggleLiteraturePanel = document.getElementById('toggleLiteraturePanel');
        const literaturePanelContent = document.getElementById('literaturePanelContent');

        const pdfViewerContainer = document.getElementById('pdfViewerContainer');
        const pdfViewerHeader = document.getElementById('pdfViewerHeader');
        const pdfViewerTitle = document.getElementById('pdfViewerTitle');
        const pdfCanvas = document.getElementById('pdfCanvas');
        const pdfCanvasContainer = document.getElementById('pdfCanvasContainer');
        const pdfTextLayer = document.getElementById('pdfTextLayer');
        const pdfSelectionOverlay = document.getElementById('pdfSelectionOverlay');
        const pdfLoadingOverlay = document.getElementById('pdfLoadingOverlay');
        const pdfCurrentPage = document.getElementById('pdfCurrentPage');
        const pdfTotalPages = document.getElementById('pdfTotalPages');
        const pdfZoomLevel = document.getElementById('pdfZoomLevel');
        const pdfSidebar = document.getElementById('pdfSidebar');
        const pdfPrevPage = document.getElementById('pdfPrevPage');
        const pdfNextPage = document.getElementById('pdfNextPage');
        const pdfPageInput = document.getElementById('pdfPageInput');
        const pdfUrlInput = document.getElementById('pdfUrlInput');
        const pdfLoadUrl = document.getElementById('pdfLoadUrl');
        const pdfOutline = document.getElementById('pdfOutline');
        const pdfSidebarSearch = document.getElementById('pdfSidebarSearch');
        const pdfSidebarSearchBtn = document.getElementById('pdfSidebarSearchBtn');
        const pdfOutlineList = document.getElementById('pdfOutlineList');
        const pdfAnnotationsList = document.getElementById('pdfAnnotationsList');
        const pdfSearchResultsList = document.getElementById('pdfSearchResultsList');
        const pdfZoomIn = document.getElementById('pdfZoomIn');
        const pdfZoomOut = document.getElementById('pdfZoomOut');
        const pdfTextSelect = document.getElementById('pdfTextSelect');
        const pdfHighlight = document.getElementById('pdfHighlight');
        const pdfScreenshot = document.getElementById('pdfScreenshot');
        const pdfDebugText = document.getElementById('pdfDebugText');
        const pdfFitWidth = document.getElementById('pdfFitWidth');
        const pdfFitPage = document.getElementById('pdfFitPage');
        const pdfRotateLeft = document.getElementById('pdfRotateLeft');
        const pdfRotateRight = document.getElementById('pdfRotateRight');
        const pdfResetRotation = document.getElementById('pdfResetRotation');
        const pdfToggleSidebar = document.getElementById('pdfToggleSidebar');
        const pdfDownload = document.getElementById('pdfDownload');
        const pdfUploadPage = document.getElementById('pdfUploadPage');
        const pdfMoreOptions = document.getElementById('pdfMoreOptions');
        const pdfMoreMenu = document.getElementById('pdfMoreMenu');
        const pdfCompactToggle = document.getElementById('pdfCompactToggle');
        const pdfHelp = document.getElementById('pdfHelp');
        const pdfResizeToggle = document.getElementById('pdfResizeToggle');
        const pdfMinimize = document.getElementById('pdfMinimize');
        const pdfCloseViewer = document.getElementById('pdfCloseViewer');

        const pdfSearchResults = document.getElementById('pdfSearchResults');
        const pdfBookmarksList = document.getElementById('pdfBookmarksList');
        const pdfSearchBtn = document.getElementById('pdfSearchBtn');
        const pdfAddNote = document.getElementById('pdfAddNote');
        const pdfAddBookmark = document.getElementById('pdfAddBookmark');

        const summarizeBtn = document.getElementById('summarizeBtn');
        const keyPointsBtn = document.getElementById('keyPointsBtn');
        const paraphraseBtn = document.getElementById('paraphraseBtn');
        const keywordExtractBtn = document.getElementById('keywordExtractBtn');
        const methodologyBtn = document.getElementById('methodologyBtn');
        const critiqueBtn = document.getElementById('critiqueBtn');
        const questionsBtn = document.getElementById('questionsBtn');
        const outlineBtn = document.getElementById('outlineBtn');
        const relatedWorkBtn = document.getElementById('relatedWorkBtn');
        const conceptMapBtn = document.getElementById('conceptMapBtn');
        const researchQuestionsBtn = document.getElementById('researchQuestionsBtn');
        const futureWorkBtn = document.getElementById('futureWorkBtn');
        const pdfUploadBtn = document.getElementById('pdfUploadBtn');
        const pdfFileInput = document.getElementById('pdfFileInput');
        const reopenPDFBtn = document.getElementById('reopenPDFBtn');
        const clearPDFBtn = document.getElementById('clearPDFBtn');
        const testPDFStatusBtn = document.getElementById('testPDFStatusBtn');
        const screenCaptureBtn = document.getElementById('screenCaptureBtn');
        const expandPanelBtn = document.getElementById('expandPanelBtn');
        const literaturePanelToggle = document.getElementById('literaturePanelToggle');
        const pdfStatusIndicator = document.getElementById('pdfStatusIndicator');

        const highlightToolbar = document.getElementById('highlightToolbar');
        const highlightYellow = document.getElementById('highlightYellow');
        const highlightGreen = document.getElementById('highlightGreen');
        const highlightBlue = document.getElementById('highlightBlue');
        const highlightPink = document.getElementById('highlightPink');
        const removeHighlight = document.getElementById('removeHighlight');
        const noteEditor = document.getElementById('noteEditor');
        const noteTitle = document.getElementById('noteTitle');
        const noteContent = document.getElementById('noteContent');
        const noteTags = document.getElementById('noteTags');
        const closeNoteEditor = document.getElementById('closeNoteEditor');
        const cancelNote = document.getElementById('cancelNote');
        const saveNote = document.getElementById('saveNote');

        let savedNotes = [];
        let highlightedTexts = [];
        let currentSelectedText = '';
        let currentSelection = null;

        const apiUrlInput = document.getElementById('apiUrl');
        const apiKeyInput = document.getElementById('apiKey');
        const modelSelect = document.getElementById('modelSelect');
        const tempSlider = document.getElementById('tempSlider');
        const tempValue = document.getElementById('tempValue');
        const streamCheckbox = document.getElementById('streamCheckbox');
        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const stopButton = document.getElementById('stopButton');
        const clearButton = document.getElementById('clearButton');
        const exportButton = document.getElementById('exportButton');
        const statusMessage = document.getElementById('statusMessage');
        const copyToast = document.getElementById('copyToast');
        const textDirectionSelect = document.getElementById('textDirectionSelect');
        const systemPrompt = document.getElementById('systemPrompt');
        const maxTokens = document.getElementById('maxTokens');
        const contextLength = document.getElementById('contextLength');
        const contextLengthDesc = document.getElementById('contextLengthDesc');
        const advancedToggle = document.getElementById('advancedToggle');
        const advancedSettings = document.getElementById('advancedSettings');
        const selectionModeCheckbox = document.getElementById('selectionModeCheckbox');
        const bulkControls = document.getElementById('bulkControls');
        const selectedCount = document.getElementById('selectedCount');
        const cancelSelectButton = document.getElementById('cancelSelectButton');
        const bulkDeleteButton = document.getElementById('bulkDeleteButton');
        const confirmDialog = document.getElementById('confirmDialog');
        const dialogTitle = document.getElementById('dialogTitle');
        const dialogMessage = document.getElementById('dialogMessage');
        const dialogCancel = document.getElementById('dialogCancel');
        const dialogConfirm = document.getElementById('dialogConfirm');
        const fileUploadContainer = document.getElementById('fileUploadContainer');
        const fileUploadClose = document.getElementById('fileUploadClose');
        const fileDropArea = document.getElementById('fileDropArea');
        const fileInput = document.getElementById('fileInput');
        const filePreview = document.getElementById('filePreview');
        const attachmentIndicator = document.getElementById('attachmentIndicator');

        const rtlRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;

        function initializeLibraries() {
            console.log('Initializing libraries...');

            if (typeof marked !== 'undefined') {
                try {
                    marked.setOptions({
                        breaks: true,
                        gfm: true,
                        headerIds: false,
                        mangle: false,
                        smartLists: true
                    });
                    console.log('✅ Marked library configured successfully');
                } catch (e) {
                    console.warn('Marked configuration failed:', e);
                }
            } else {
                console.error('❌ Marked library not loaded');
                showStatus('Markdown库未加载，部分功能可能无法使用', 'error');
            }

            if (typeof pdfjsLib !== 'undefined') {

                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                console.log('✅ PDF.js library configured successfully');
                console.log('PDF.js version:', pdfjsLib.version);
            } else {
                console.error('❌ PDF.js library not loaded');
                showStatus('PDF.js库未加载，PDF功能将无法使用', 'error');
            }
        }

        function parseMarkdown(content) {
            if (typeof marked === 'undefined') {
                console.warn('Marked library not available, returning plain text');
                return content.replace(/\n/g, '<br>');
            }

            try {

                if (typeof marked.parse === 'function') {
                    return marked.parse(content);
                }

                else if (typeof marked === 'function') {
                    return marked(content);
                }
                else {
                    console.warn('Unknown marked API, returning plain text');
                    return content.replace(/\n/g, '<br>');
                }
            } catch (e) {
                console.error('Markdown parsing failed:', e);
                return content.replace(/\n/g, '<br>');
            }
        }

        function extractPlainText(htmlContent) {

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;

            const timestamps = tempDiv.querySelectorAll('.message-timestamp');
            timestamps.forEach(el => el.remove());

            const actions = tempDiv.querySelectorAll('.message-actions');
            actions.forEach(el => el.remove());

            return tempDiv.textContent || tempDiv.innerText || "";
        }

        function autoResizeTextarea(textarea) {

            textarea.style.height = 'auto';

            const newHeight = Math.min(textarea.scrollHeight, 150);
            textarea.style.height = newHeight + 'px';
        }

        messageInput.addEventListener('input', function () {
            autoResizeTextarea(this);
        });

        if (pdfTextSelect) {
            pdfTextSelect.addEventListener('click', toggleTextSelectionMode);
        }

        if (pdfHighlight) {
            pdfHighlight.addEventListener('click', highlightSelectedText);
        }

        if (pdfScreenshot) {
            pdfScreenshot.addEventListener('click', toggleScreenshotMode);
        }

        if (pdfDebugText) {
            pdfDebugText.addEventListener('click', toggleTextLayerDebug);
        }

        if (pdfToggleSidebar) {
            pdfToggleSidebar.addEventListener('click', togglePDFSidebar);
        }

        if (pdfOutline) {
            pdfOutline.addEventListener('click', () => {
                if (!pdfSidebar.style.display || pdfSidebar.style.display === 'none') {
                    togglePDFSidebar();
                }
                switchSidebarTab('outline');
            });
        }

        document.querySelectorAll('.pdf-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;
                switchSidebarTab(tabName);
            });
        });

        if (pdfSidebarSearchBtn && pdfSidebarSearch) {
            pdfSidebarSearchBtn.addEventListener('click', performSidebarSearch);
            pdfSidebarSearch.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    performSidebarSearch();
                }
            });
        }

        if (pdfPageInput) {
            pdfPageInput.addEventListener('change', () => {
                const pageNum = parseInt(pdfPageInput.value);
                if (pageNum >= 1 && pageNum <= totalPages) {
                    renderPDFPage(pageNum);
                } else {
                    pdfPageInput.value = currentPage;
                    showStatus('页面号超出范围', 'error');
                }
            });

            pdfPageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    pdfPageInput.blur();
                }
            });
        }

        if (pdfLoadUrl && pdfUrlInput) {
            pdfLoadUrl.addEventListener('click', () => {
                const url = pdfUrlInput.value.trim();
                if (url) {
                    loadPDFFromUrl(url);
                } else {
                    showStatus('请输入有效的URL', 'warning');
                }
            });

            pdfUrlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const url = pdfUrlInput.value.trim();
                    if (url) {
                        loadPDFFromUrl(url);
                    } else {
                        showStatus('请输入有效的URL', 'warning');
                    }
                }
            });
        }

        if (pdfDownload) {
            pdfDownload.addEventListener('click', downloadPDF);
        }

        if (pdfUploadPage) {
            pdfUploadPage.addEventListener('click', showPageUploadDialog);
        }

        function initMoreOptionsMenu() {
            const pdfMoreOptions = document.getElementById('pdfMoreOptions');
            const pdfMoreMenu = document.getElementById('pdfMoreMenu');

            if (pdfMoreOptions && pdfMoreMenu) {

                pdfMoreOptions.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = pdfMoreMenu.style.display === 'block';
                    pdfMoreMenu.style.display = isVisible ? 'none' : 'block';
                    console.log('更多选项菜单切换:', isVisible ? '关闭' : '打开');
                });

                pdfMoreMenu.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const target = e.target;

                    if (target.classList.contains('pdf-menu-item')) {

                        pdfMoreMenu.style.display = 'none';

                        const buttonId = target.id;
                        const button = document.getElementById(buttonId);
                        if (button) {
                            console.log('触发菜单项:', buttonId);
                            button.click();
                        }
                    }
                });

                console.log('✅ 更多选项菜单已初始化');
            } else {
                console.log('❌ 更多选项菜单元素未找到');
            }
        }

        document.addEventListener('click', () => {
            const pdfMoreMenu = document.getElementById('pdfMoreMenu');
            if (pdfMoreMenu) {
                pdfMoreMenu.style.display = 'none';
            }
        });

        if (pdfCompactToggle) {
            pdfCompactToggle.addEventListener('click', () => {
                const container = document.getElementById('pdfViewerContainer');
                const isCompact = container.classList.contains('compact');

                if (isCompact) {
                    container.classList.remove('compact');
                    pdfCompactToggle.classList.remove('active');
                    pdfCompactToggle.title = '紧凑模式';
                    showStatus('已切换到标准模式', 'info');
                } else {
                    container.classList.add('compact');
                    pdfCompactToggle.classList.add('active');
                    pdfCompactToggle.title = '标准模式';
                    showStatus('已切换到紧凑模式', 'info');
                }
            });
        }

        function checkControlsOverflow() {
            const controls = document.querySelector('.pdf-viewer-controls');
            const container = document.getElementById('pdfViewerContainer');

            if (!controls || !container) return;

            if (controls.scrollWidth > controls.clientWidth) {
                if (!container.classList.contains('compact')) {

                    console.log('💡 控制栏空间不足，建议切换到紧凑模式');

                }
            }
        }

        window.addEventListener('resize', checkControlsOverflow);

        if (window.ResizeObserver) {
            const resizeObserver = new ResizeObserver(checkControlsOverflow);
            const pdfContainer = document.getElementById('pdfViewerContainer');
            if (pdfContainer) {
                resizeObserver.observe(pdfContainer);
            }
        }

        if (pdfHelp) {
            pdfHelp.addEventListener('click', showPDFHelp);
        }

        if (pdfCloseViewer) {
            pdfCloseViewer.addEventListener('click', closePDFViewer);
        }

        if (pdfMinimize) {
            pdfMinimize.addEventListener('click', () => {
                const container = pdfViewerContainer;
                const isMinimized = container.classList.contains('minimized');

                console.log('最小化按钮点击，当前状态:', isMinimized);

                if (isMinimized) {

                    container.classList.remove('minimized');
                    pdfMinimize.textContent = '−';
                    pdfMinimize.title = '最小化';
                    showStatus('PDF预览器已还原', 'info');
                    console.log('PDF预览器已还原');
                } else {

                    container.classList.add('minimized');
                    pdfMinimize.textContent = '□';
                    pdfMinimize.title = '还原';
                    showStatus('PDF预览器已最小化，点击"□"按钮可还原', 'info');
                    console.log('PDF预览器已最小化');
                }
            });
        }

        document.addEventListener('keydown', (e) => {

            if (!pdfViewerContainer || !pdfViewerContainer.classList.contains('active')) return;

            const isInInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';

            if (e.ctrlKey && e.key === 'm') {
                e.preventDefault();
                if (pdfMinimize) pdfMinimize.click();
            }

            if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                if (pdfResizeToggle) pdfResizeToggle.click();
            }

            if (e.key === 'Escape') {
                e.preventDefault();
                if (isScreenshotMode) {
                    toggleScreenshotMode();
                } else if (pdfCloseViewer) {
                    pdfCloseViewer.click();
                }
            }

            if (isInInput) return;

            if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                if (screenCaptureBtn) toggleScreenshotMode();
            }

            if (e.key === 't' || e.key === 'T') {
                e.preventDefault();
                if (pdfTextSelect) toggleTextSelectionMode();
            }

            if (e.key === 'h' || e.key === 'H') {
                e.preventDefault();
                if (pdfHighlight) highlightSelectedText();
            }

            if (e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                if (e.shiftKey) {

                    rotatePDF(-90);
                } else if (e.ctrlKey) {

                    resetPDFRotation();
                } else {

                    rotatePDF(90);
                }
            }

            if (e.key === 'ArrowLeft' || (e.key === 'ArrowUp' && e.ctrlKey)) {
                e.preventDefault();
                if (currentPage > 1) renderPDFPage(currentPage - 1);
            }

            if (e.key === 'ArrowRight' || (e.key === 'ArrowDown' && e.ctrlKey)) {
                e.preventDefault();
                if (currentPage < totalPages) renderPDFPage(currentPage + 1);
            }

            if (e.key === 'ArrowUp' && !e.ctrlKey) {
                e.preventDefault();
                pdfCanvasContainer.scrollTop -= 50;
            }

            if (e.key === 'ArrowDown' && !e.ctrlKey) {
                e.preventDefault();
                pdfCanvasContainer.scrollTop += 50;
            }

            if (e.key === 'PageUp') {
                e.preventDefault();
                if (e.ctrlKey && currentPage > 1) {
                    renderPDFPage(currentPage - 1);
                } else {
                    pdfCanvasContainer.scrollTop -= pdfCanvasContainer.clientHeight * 0.9;
                }
            }

            if (e.key === 'PageDown') {
                e.preventDefault();
                if (e.ctrlKey && currentPage < totalPages) {
                    renderPDFPage(currentPage + 1);
                } else {
                    pdfCanvasContainer.scrollTop += pdfCanvasContainer.clientHeight * 0.9;
                }
            }

            if (e.key === 'Home') {
                e.preventDefault();
                if (e.ctrlKey) {

                    if (currentPage > 1) renderPDFPage(1);
                } else {

                    pdfCanvasContainer.scrollTop = 0;
                }
            }

            if (e.key === 'End') {
                e.preventDefault();
                if (e.ctrlKey) {

                    if (currentPage < totalPages) renderPDFPage(totalPages);
                } else {

                    pdfCanvasContainer.scrollTop = pdfCanvasContainer.scrollHeight;
                }
            }

            if (e.key === '=' || e.key === '+') {
                e.preventDefault();
                zoomPDF(1.2);
            }

            if (e.key === '-') {
                e.preventDefault();
                zoomPDF(0.8);
            }

            if (e.key === '0' && e.ctrlKey) {
                e.preventDefault();
                currentScale = 1.0;
                renderPDFPage(currentPage);
            }

            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                const urlInput = document.getElementById('pdfUrlInput');
                if (urlInput) {
                    urlInput.focus();
                    urlInput.select();
                }
            }
        });

        if (pdfResizeToggle) {
            let currentSizeMode = 0;
            const sizeModes = [
                { width: '60vw', height: '80vh', name: '中等' },
                { width: '80vw', height: '90vh', name: '大' },
                { width: '40vw', height: '60vh', name: '小' }
            ];

            pdfResizeToggle.addEventListener('click', () => {
                const container = pdfViewerContainer;
                if (container.classList.contains('minimized')) return;

                currentSizeMode = (currentSizeMode + 1) % sizeModes.length;
                const mode = sizeModes[currentSizeMode];

                container.style.width = mode.width;
                container.style.height = mode.height;

                container.style.transform = 'translate(0px, 0px)';

                showStatus('PDF预览器大小已调整为: ' + mode.name, 'info');
            });
        }

        if (pdfPrevPage) {
            pdfPrevPage.addEventListener('click', () => changePDFPage(-1));
        }

        if (pdfNextPage) {
            pdfNextPage.addEventListener('click', () => changePDFPage(1));
        }

        if (pdfZoomIn) {
            pdfZoomIn.addEventListener('click', () => zoomPDF(1.25));
        }

        if (pdfZoomOut) {
            pdfZoomOut.addEventListener('click', () => zoomPDF(0.8));
        }

        if (pdfFitWidth) {
            pdfFitWidth.addEventListener('click', fitPDFWidth);
        }

        if (pdfFitPage) {
            pdfFitPage.addEventListener('click', fitPDFPage);
        }

        if (pdfRotateLeft) {
            pdfRotateLeft.addEventListener('click', () => rotatePDF(-90));
        }

        if (pdfRotateRight) {
            pdfRotateRight.addEventListener('click', () => rotatePDF(90));
        }

        if (pdfResetRotation) {
            pdfResetRotation.addEventListener('click', resetPDFRotation);
        }

        if (pdfToggleSidebar) {
            pdfToggleSidebar.addEventListener('click', () => {
                pdfSidebar.classList.toggle('mobile-open');
            });
        }

        if (pdfAddNote) {
            pdfAddNote.addEventListener('click', () => {
                const text = prompt('请输入注释内容:');
                if (text && text.trim()) {
                    addPDFAnnotation(text.trim(), currentPage, null);
                }
            });
        }

        if (pdfAddBookmark) {
            pdfAddBookmark.addEventListener('click', () => {
                const title = prompt('请输入书签标题:', '页面 ' + currentPage);
                if (title && title.trim()) {
                    addPDFBookmark(title.trim(), currentPage);
                }
            });
        }

        if (toggleLiteraturePanel) {

            if (literaturePanelCollapsed) {
                literaturePanelContent.classList.add('collapsed');
                literaturePanelToggle.textContent = '▶';
                literaturePanelToggle.classList.add('collapsed');
            } else {
                literaturePanelContent.classList.remove('collapsed');
                literaturePanelToggle.textContent = '▼';
                literaturePanelToggle.classList.remove('collapsed');
            }

            toggleLiteraturePanel.addEventListener('click', () => {
                literaturePanelCollapsed = !literaturePanelCollapsed;
                console.log('文献面板切换:', literaturePanelCollapsed ? '收起' : '展开');

                if (literaturePanelCollapsed) {
                    literaturePanelContent.classList.add('collapsed');
                    literaturePanelToggle.textContent = '▶';
                    literaturePanelToggle.classList.add('collapsed');
                } else {
                    literaturePanelContent.classList.remove('collapsed');
                    literaturePanelToggle.textContent = '▼';
                    literaturePanelToggle.classList.remove('collapsed');
                }
            });
        }

        async function processSelectedText(action) {

            logPDFStatus('进入processSelectedText函数');

            await new Promise(resolve => setTimeout(resolve, 100));

            logPDFStatus('延迟100ms后的PDF状态');

            let textToAnalyze = '';
            let isFullPDF = false;
            let pdfFile = null;

            const isPDFLoaded = currentPDF && totalPages > 0 && currentPDFFile;
            const isPDFViewerOpen = pdfViewerContainer && pdfViewerContainer.classList.contains('active');

            console.log('=== PDF检测状态详情 ===');
            console.log('pdfViewerContainer存在:', !!pdfViewerContainer);
            console.log('PDF预览器是否打开:', isPDFViewerOpen);
            console.log('currentPDF存在:', !!currentPDF);
            console.log('totalPages:', totalPages);
            console.log('currentPDFFile存在:', !!currentPDFFile);
            console.log('currentPDFFileName:', currentPDFFileName);
            console.log('最终PDF检测结果:', isPDFLoaded);

            if (isPDFLoaded) {
                showStatus('准备PDF文件用于分析...', 'info');

                try {

                    pdfFile = await getCurrentPDFFile();
                    isFullPDF = true;

                    console.log('PDF文件准备结果:', {
                        pdfFileExists: !!pdfFile,
                        pdfFileName: pdfFile ? pdfFile.name : 'null',
                        fileSize: pdfFile ? pdfFile.size : 0
                    });

                    if (!pdfFile) {
                        showStatus('PDF文件获取失败，请重新上传PDF', 'error');
                        return;
                    }

                } catch (error) {
                    console.error('PDF处理错误:', error);
                    showStatus('PDF处理失败: ' + error.message, 'error');
                    return;
                }
            } else {

                const selectedText = window.getSelection().toString().trim();
                if (!selectedText) {
                    showStatus('请先在PDF工具中上传PDF文档，或选择要处理的文本', 'error');
                    return;
                }
                textToAnalyze = selectedText;
                console.log('使用选中文本，长度:', textToAnalyze.length);
            }

            let prompt = '';

            if (isFullPDF) {

                switch (action) {
                    case 'summarize':
                        prompt = '请对附件中的PDF文档进行智能摘要，提取核心观点和主要内容。请按以下结构组织：\n\n1. 研究背景与目的\n2. 主要方法\n3. 核心发现\n4. 结论与意义\n\n请直接分析PDF文件内容，包括文本、图表、公式等所有信息。';
                        break;
                    case 'keyPoints':
                        prompt = '请提取附件PDF文档的关键要点，以条目形式列出。请分类整理为：\n\n📋 主要论点\n🔬 研究方法\n📊 重要数据/发现\n💡 创新点\n🎯 实际应用\n\n请分析PDF中的完整内容，包括图表和公式。';
                        break;
                    case 'keywords':
                        prompt = '请从附件PDF文档中提取关键词和专业术语，并按重要性排序。请分为：\n\n🏷️ 核心概念（5-8个）\n🔬 研究方法术语\n📚 学科专业词汇\n🌐 相关领域术语\n\n请全面分析PDF内容进行提取。';
                        break;
                    case 'paraphrase':
                        prompt = '请对附件PDF文档的关键内容进行学术改写和润色，保持原意但改善表达，使其更适合学术写作引用。请重点关注核心观点和重要发现。';
                        break;
                    case 'methodology':
                        prompt = '请详细分析附件PDF文档的研究方法，包括：\n\n🔬 研究设计\n📊 数据收集方法\n📈 分析技术\n⚖️ 方法的优缺点\n🎯 适用场景\n\n请分析PDF中的方法论部分，包括图表说明。';
                        break;
                    case 'critique':
                        prompt = '请对附件PDF文档进行批判性分析，包括：\n\n💪 研究优势\n⚠️ 局限性\n❓ 潜在问题\n🔄 改进建议\n📚 与其他研究的关系\n\n请全面评估PDF文档的学术价值。';
                        break;
                    case 'questions':
                        prompt = '基于附件PDF文档，请生成深度思考问题，帮助更好理解和应用：\n\n🤔 理解性问题（3-5个）\n🔍 批判性问题（3-5个）\n💡 应用性问题（3-5个）\n🚀 拓展性问题（3-5个）\n\n请基于PDF的完整内容生成问题。';
                        break;
                    default:
                        prompt = '请分析附件中的PDF文档，提供详细的学术分析。';
                }
            } else {

                const sourceInfo = '选中文本';
                switch (action) {
                    case 'summarize':
                        prompt = '请对以下' + sourceInfo + '进行智能摘要：\n\n' + textToAnalyze;
                        break;
                    case 'keyPoints':
                        prompt = '请提取以下' + sourceInfo + '的关键要点：\n\n' + textToAnalyze;
                        break;
                    case 'keywords':
                        prompt = '请从以下' + sourceInfo + '中提取关键词：\n\n' + textToAnalyze;
                        break;
                    case 'paraphrase':
                        prompt = '请改写以下' + sourceInfo + '：\n\n' + textToAnalyze;
                        break;
                    case 'methodology':
                        prompt = '请分析以下' + sourceInfo + '的研究方法：\n\n' + textToAnalyze;
                        break;
                    case 'critique':
                        prompt = '请批判性分析以下' + sourceInfo + '：\n\n' + textToAnalyze;
                        break;
                    case 'questions':
                        prompt = '基于以下' + sourceInfo + '生成思考问题：\n\n' + textToAnalyze;
                        break;
                    default:
                        prompt = '请分析以下' + sourceInfo + '：\n\n' + textToAnalyze;
                }
            }

            if (pdfFile && isFullPDF) {
                console.log('开始上传PDF文件到附件区:', pdfFile.name);

                try {

                    const existingFile = uploadedFiles.find(f => f.name === pdfFile.name && f.size === pdfFile.size);
                    if (!existingFile) {
                        uploadedFiles.push(pdfFile);
                        const fileId = 'pdf_analysis_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        addFilePreview(pdfFile, fileId);

                        showStatus('正在上传PDF文件，请稍候...', 'info');

                        await uploadFile(pdfFile, fileId);

                        updateAttachmentIndicator();
                        fileUploadContainer.classList.add('active');
                        console.log('PDF文件已添加到附件区，文件ID:', fileId);
                    } else {
                        console.log('PDF文件已存在于附件区，跳过重复上传');
                    }
                } catch (error) {
                    console.error('PDF文件上传到附件区失败:', error);
                    showStatus('PDF文件上传失败: ' + error.message, 'error');
                    return;
                }
            }

            console.log('发送分析请求，提示词长度:', prompt.length);
            messageInput.value = prompt;
            sendMessage();

            if (isFullPDF) {
                showStatus('PDF文档"' + currentPDFFileName + '"分析请求已发送，PDF已作为附件上传', 'success');
            }
        }

        async function processDocumentAnalysis(action) {
            let textToAnalyze = '';
            let isFullPDF = false;
            let pdfFile = null;

            const isPDFLoaded = currentPDF && totalPages > 0 && currentPDFFile;
            const isPDFViewerOpen = pdfViewerContainer && pdfViewerContainer.classList.contains('active');

            console.log('研究工具PDF检测状态:', {
                isPDFViewerOpen,
                isPDFLoaded,
                currentPDF: !!currentPDF,
                totalPages,
                currentPDFFile: !!currentPDFFile
            });

            if (isPDFLoaded) {
                showStatus('准备PDF文件用于研究分析...', 'info');
                isFullPDF = true;
                pdfFile = await getCurrentPDFFile();

                if (!pdfFile) {
                    showStatus('PDF文件获取失败，请重新上传PDF', 'error');
                    return;
                }

                console.log('研究工具PDF文件准备成功:', pdfFile.name);
            }

            let prompt = '';

            switch (action) {
                case 'concept':
                    if (isFullPDF) {
                        prompt = '请基于附件PDF文档生成概念图谱，展示知识结构和概念关系：\n\n📊 核心概念及其关系\n🔗 概念间的逻辑连接\n🏗️ 知识层次结构\n🎯 关键术语定义\n\n请分析PDF中的完整内容，包括图表和公式。';
                    } else {
                        prompt = '请提供研究主题或上传PDF文献，我将为您生成概念图谱，展示知识结构。';
                    }
                    break;
                case 'research_questions':
                    if (isFullPDF) {
                        prompt = '基于附件PDF文档，请生成相关的研究问题和研究方向：\n\n🔍 基础研究问题\n🚀 拓展研究方向\n💡 创新研究角度\n🎯 实际应用问题\n📈 未来发展趋势\n\n请全面分析PDF内容生成问题。';
                    } else {
                        prompt = '请描述您的研究方向或上传PDF文献，我将帮您生成相关的研究问题。';
                    }
                    break;
                case 'outline':
                    if (isFullPDF) {
                        prompt = '基于附件PDF文档，请帮我生成一个相关主题的论文大纲：\n\n📝 论文标题建议\n📋 章节结构\n🎯 各章节要点\n📚 可能的参考文献方向\n\n请基于PDF的研究内容和结构生成大纲。';
                    } else {
                        prompt = '请上传PDF文献或描述研究主题，我将帮您生成论文大纲。';
                    }
                    break;
                case 'related_work':
                    if (isFullPDF) {
                        prompt = '基于附件PDF文档，请帮我分析相关工作和研究现状：\n\n📚 主要相关研究\n🔄 研究发展脉络\n📊 不同方法比较\n🎯 研究空白识别\n💡 本研究的定位\n\n请分析PDF中提到的相关工作和引用文献。';
                    } else {
                        prompt = '请上传PDF文献，我将帮您分析相关工作和研究现状。';
                    }
                    break;
                case 'future_work':
                    if (isFullPDF) {
                        prompt = '基于附件PDF文档，请分析并建议未来研究方向：\n\n🚀 直接延续方向\n💡 创新拓展方向\n🔧 方法改进方向\n🌐 跨领域应用\n⚠️ 需要解决的问题\n\n请基于PDF的研究内容和局限性分析未来方向。';
                    } else {
                        prompt = '请上传PDF文献，我将帮您分析未来研究方向。';
                    }
                    break;
                default:
                    prompt = '请描述您需要的学术分析类型。';
            }

            if (pdfFile && isFullPDF) {
                console.log('研究工具：开始上传PDF文件到附件区:', pdfFile.name);

                try {

                    const existingFile = uploadedFiles.find(f => f.name === pdfFile.name && f.size === pdfFile.size);
                    if (!existingFile) {
                        uploadedFiles.push(pdfFile);
                        const fileId = 'pdf_research_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        addFilePreview(pdfFile, fileId);

                        showStatus('正在上传PDF文件，请稍候...', 'info');

                        await uploadFile(pdfFile, fileId);

                        updateAttachmentIndicator();
                        fileUploadContainer.classList.add('active');
                        console.log('研究工具：PDF文件已添加到附件区，文件ID:', fileId);
                    } else {
                        console.log('研究工具：PDF文件已存在于附件区，跳过重复上传');
                    }
                } catch (error) {
                    console.error('研究工具：PDF文件上传到附件区失败:', error);
                    showStatus('PDF文件上传失败: ' + error.message, 'error');
                    return;
                }
            }

            console.log('研究工具：发送分析请求，提示词长度:', prompt.length);
            messageInput.value = prompt;
            sendMessage();

            if (isFullPDF) {
                showStatus('PDF文档分析请求已发送，PDF已作为附件上传', 'success');
            }
        }

        if (summarizeBtn) {
            summarizeBtn.addEventListener('click', () => processSelectedText('summarize'));
        }

        if (keyPointsBtn) {
            keyPointsBtn.addEventListener('click', () => processSelectedText('keyPoints'));
        }

        if (keywordExtractBtn) {
            keywordExtractBtn.addEventListener('click', () => processSelectedText('keywords'));
        }

        if (paraphraseBtn) {
            paraphraseBtn.addEventListener('click', () => processSelectedText('paraphrase'));
        }

        if (methodologyBtn) {
            methodologyBtn.addEventListener('click', () => processSelectedText('methodology'));
        }

        if (critiqueBtn) {
            critiqueBtn.addEventListener('click', () => processSelectedText('critique'));
        }

        if (questionsBtn) {
            questionsBtn.addEventListener('click', () => processSelectedText('questions'));
        }

        if (outlineBtn) {
            outlineBtn.addEventListener('click', () => processDocumentAnalysis('outline'));
        }

        if (relatedWorkBtn) {
            relatedWorkBtn.addEventListener('click', () => processDocumentAnalysis('related_work'));
        }

        if (conceptMapBtn) {
            conceptMapBtn.addEventListener('click', () => processDocumentAnalysis('concept'));
        }

        if (researchQuestionsBtn) {
            researchQuestionsBtn.addEventListener('click', () => processDocumentAnalysis('research_questions'));
        }

        if (futureWorkBtn) {
            futureWorkBtn.addEventListener('click', () => processDocumentAnalysis('future_work'));
        }

        if (pdfUploadBtn && pdfFileInput) {
            pdfUploadBtn.addEventListener('click', () => {
                pdfFileInput.click();
            });

            pdfFileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === 'application/pdf') {
                        openPDFViewer(file, file.name);
                        showStatus('PDF文件 "' + file.name + '" 已在预览器中打开', 'success');
                    } else {
                        showStatus('请选择PDF文件', 'error');
                    }
                }

                pdfFileInput.value = '';
            });
        }

        if (screenCaptureBtn) {
            screenCaptureBtn.addEventListener('click', () => {
                toggleScreenshotMode();
            });
        }

        if (reopenPDFBtn) {
            reopenPDFBtn.addEventListener('click', () => {
                if (currentPDF && currentPDFFile) {
                    console.log('重新打开PDF预览器:', currentPDFFileName);
                    pdfViewerContainer.classList.add('active');

                    initPDFDragging();

                    updatePDFStatusIndicator();

                    reopenPDFBtn.style.display = 'none';

                    showStatus('PDF预览器已重新打开: ' + currentPDFFileName, 'success');
                } else {
                    showStatus('没有可重新打开的PDF文件', 'error');
                }
            });
        }

        if (clearPDFBtn) {
            clearPDFBtn.addEventListener('click', () => {
                if (confirm('确定要清除当前PDF文件吗？这将清除所有PDF相关状态。')) {
                    console.log('🗑️ 用户手动清除PDF状态');

                    pdfViewerContainer.classList.remove('active');
                    currentPDF = null;
                    currentPDFFile = null;
                    currentPDFFileName = '';
                    currentPage = 1;
                    totalPages = 0;
                    currentScale = 1.0;

                    clearPDFSelection();

                    pdfAnnotations = [];
                    pdfBookmarks = [];
                    updatePDFAnnotationsList();
                    updatePDFBookmarksList();

                    logPDFStatus('手动清除PDF后');
                    updatePDFStatusIndicator();
                    showStatus('PDF状态已清除', 'success');
                }
            });
        }

        if (testPDFStatusBtn) {
            testPDFStatusBtn.addEventListener('click', () => {
                console.log('=== PDF状态测试 ===');
                console.log('pdfViewerContainer:', !!pdfViewerContainer);
                console.log('pdfViewerContainer.classList:', pdfViewerContainer ? Array.from(pdfViewerContainer.classList) : 'null');
                console.log('currentPDF:', !!currentPDF);
                console.log('currentPDFFile:', !!currentPDFFile);
                console.log('currentPDFFileName:', currentPDFFileName);
                console.log('totalPages:', totalPages);

                const isPDFViewerOpen = pdfViewerContainer && pdfViewerContainer.classList.contains('active');
                const isPDFLoaded = currentPDF && totalPages > 0 && currentPDFFile;

                alert('PDF状态检测结果:\n预览器打开: ' + isPDFViewerOpen + '\nPDF已加载: ' + isPDFLoaded + '\n文件名: ' + currentPDFFileName + '\n页数: ' + totalPages);
            });
        }

        if (expandPanelBtn) {
            expandPanelBtn.addEventListener('click', () => {
                literaturePanel.classList.toggle('expanded');
                expandPanelBtn.textContent = literaturePanel.classList.contains('expanded') ? '收起面板' : '展开面板';
            });
        }

        function startScreenCapture() {
            if (isCapturing) return;

            isCapturing = true;

            captureOverlay = document.createElement('div');
            captureOverlay.className = 'screen-capture-overlay';

            const instructions = document.createElement('div');
            instructions.className = 'capture-instructions';
            instructions.textContent = '拖拽鼠标选择要截取的区域，按ESC键取消';
            captureOverlay.appendChild(instructions);

            selectionRect = document.createElement('div');
            selectionRect.className = 'selection-rectangle';
            captureOverlay.appendChild(selectionRect);

            document.body.appendChild(captureOverlay);

            let isSelecting = false;
            let startX, startY;

            captureOverlay.addEventListener('mousedown', (e) => {
                isSelecting = true;
                startX = e.clientX;
                startY = e.clientY;

                selectionRect.style.left = startX + 'px';
                selectionRect.style.top = startY + 'px';
                selectionRect.style.width = '0px';
                selectionRect.style.height = '0px';
                selectionRect.style.display = 'block';
            });

            captureOverlay.addEventListener('mousemove', (e) => {
                if (!isSelecting) return;

                const currentX = e.clientX;
                const currentY = e.clientY;

                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);
                const left = Math.min(currentX, startX);
                const top = Math.min(currentY, startY);

                selectionRect.style.left = left + 'px';
                selectionRect.style.top = top + 'px';
                selectionRect.style.width = width + 'px';
                selectionRect.style.height = height + 'px';
            });

            captureOverlay.addEventListener('mouseup', (e) => {
                if (!isSelecting) return;
                isSelecting = false;

                const currentX = e.clientX;
                const currentY = e.clientY;

                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);

                if (width > 10 && height > 10) {

                    captureScreenArea(
                        Math.min(currentX, startX),
                        Math.min(currentY, startY),
                        width,
                        height
                    );
                }

                endScreenCapture();
            });

            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    endScreenCapture();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }

        function endScreenCapture() {
            isCapturing = false;
            if (captureOverlay) {
                document.body.removeChild(captureOverlay);
                captureOverlay = null;
                selectionRect = null;
            }
        }

        async function captureScreenArea(x, y, width, height) {
            try {

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = width;
                canvas.height = height;

                showStatus('屏幕截图功能需要用户手动截图后上传，或使用PDF预览器的截图功能', 'info');

                fileUploadContainer.classList.add('active');

            } catch (error) {
                console.error('截图失败:', error);
                showStatus('截图失败，请手动截图后上传', 'error');
            }
        }

        attachmentIndicator.addEventListener('click', () => {
            fileUploadContainer.classList.toggle('active');
        });

        fileUploadClose.addEventListener('click', () => {
            fileUploadContainer.classList.remove('active');
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            fileDropArea.classList.add('dragging');
        }

        function unhighlight() {
            fileDropArea.classList.remove('dragging');
        }

        fileDropArea.addEventListener('drop', handleDrop, false);
        fileInput.addEventListener('change', handleFiles, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFileList(files);
        }

        function handleFiles(e) {
            const files = e.target.files;
            handleFileList(files);
        }

        function handleFileList(files) {
            if (files.length === 0) return;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];

                if (file.size > 10 * 1024 * 1024) {
                    showStatus('文件 ' + file.name + ' 超过10MB限制，无法上传', 'error');
                    continue;
                }

                uploadedFiles.push(file);

                const fileId = 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                addFilePreview(file, fileId);

                uploadFile(file, fileId);
            }

            updateAttachmentIndicator();

            fileInput.value = '';
        }

        function addFilePreview(file, fileId) {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.dataset.id = fileId;

            const thumbnail = document.createElement('div');
            thumbnail.className = 'file-thumbnail';

            if (file.type.startsWith('image/')) {
                const img = document.createElement('img');
                const reader = new FileReader();
                reader.onload = (e) => {
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
                thumbnail.appendChild(img);
            } else {

                const fileIcon = document.createElement('div');
                fileIcon.className = 'file-icon';

                if (file.type.includes('pdf')) {
                    fileIcon.innerHTML = '📄';
                } else if (file.type.includes('word') || file.type.includes('document')) {
                    fileIcon.innerHTML = '📝';
                } else if (file.type.includes('spreadsheet') || file.type.includes('excel')) {
                    fileIcon.innerHTML = '📊';
                } else if (file.type.includes('presentation') || file.type.includes('powerpoint')) {
                    fileIcon.innerHTML = '📊';
                } else if (file.type.includes('text')) {
                    fileIcon.innerHTML = '📃';
                } else if (file.type.includes('zip') || file.type.includes('rar') || file.type.includes('archive')) {
                    fileIcon.innerHTML = '📦';
                } else if (file.type.includes('audio')) {
                    fileIcon.innerHTML = '🎵';
                } else if (file.type.includes('video')) {
                    fileIcon.innerHTML = '🎬';
                } else {
                    fileIcon.innerHTML = '📁';
                }

                thumbnail.appendChild(fileIcon);
            }

            const fileInfo = document.createElement('div');
            fileInfo.className = 'file-info';

            const fileName = document.createElement('div');
            fileName.className = 'file-name';
            fileName.title = file.name;
            fileName.textContent = file.name;

            const fileSize = document.createElement('div');
            fileSize.className = 'file-size';
            fileSize.textContent = formatFileSize(file.size);

            const fileStatus = document.createElement('div');
            fileStatus.className = 'file-status uploading';
            fileStatus.textContent = '上传中...';
            fileStatus.dataset.id = fileId;

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'file-delete';
            deleteBtn.innerHTML = '×';
            deleteBtn.title = '删除文件';
            deleteBtn.addEventListener('click', () => {

                const fileIndex = uploadedFiles.findIndex(f => f === file);
                if (fileIndex !== -1) {
                    uploadedFiles.splice(fileIndex, 1);
                }

                const urlIndex = uploadedFileUrls.findIndex(u => u.fileId === fileId);
                if (urlIndex !== -1) {
                    uploadedFileUrls.splice(urlIndex, 1);
                }

                fileItem.remove();

                updateAttachmentIndicator();
            });

            fileInfo.appendChild(fileName);
            fileInfo.appendChild(fileSize);
            fileInfo.appendChild(fileStatus);
            fileItem.appendChild(thumbnail);
            fileItem.appendChild(fileInfo);
            fileItem.appendChild(deleteBtn);

            filePreview.appendChild(fileItem);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function updateAttachmentIndicator() {
            if (uploadedFileUrls.length > 0) {
                attachmentIndicator.classList.add('active');
                attachmentIndicator.title = '已添加 ' + uploadedFileUrls.length + ' 个文件';
            } else {
                attachmentIndicator.classList.remove('active');
                attachmentIndicator.title = '添加附件';
            }
        }

        async function uploadFile(file, fileId) {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                updateFileStatus(fileId, 'error', '未设置API Key');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('https://api.2023gpt.top/fileSystem/upload', {
                    method: 'POST',
                    headers: {
                        'Authorization': apiKey
                    },
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('上传失败: ' + response.status);
                }

                const result = await response.json();

                if (result.success) {

                    updateFileStatus(fileId, 'success', '上传成功');

                    uploadedFileUrls.push({
                        fileId: fileId,
                        url: result.url,
                        filename: file.name
                    });

                    updateAttachmentIndicator();
                } else {
                    throw new Error(result.message || '上传失败');
                }
            } catch (error) {
                console.error('文件上传错误:', error);
                updateFileStatus(fileId, 'error', '上传失败');
            }
        }

        function updateFileStatus(fileId, status, message) {
            const statusElement = document.querySelector('.file-status[data-id="' + fileId + '"]');
            if (statusElement) {
                statusElement.className = 'file-status ' + status;
                statusElement.textContent = message;
            }
        }

        function initPDFDragging() {
            console.log('🔧 初始化PDF拖拽功能...');

            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            const header = pdfViewerHeader;
            const container = pdfViewerContainer;

            console.log('🔍 拖拽元素检查:', {
                header: !!header,
                headerElement: header,
                container: !!container,
                containerElement: container
            });

            if (!header || !container) {
                console.error('❌ 拖拽初始化失败: 缺少必要的DOM元素');
                return;
            }

            header.style.cursor = 'move';
            header.title = '拖拽移动PDF预览器';

            function dragStart(e) {
                console.log('🖱️ 鼠标按下事件:', {
                    target: e.target.tagName,
                    targetClass: e.target.className,
                    isButton: e.target.tagName === 'BUTTON',
                    isInput: e.target.tagName === 'INPUT'
                });

                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    console.log('⏭️ 跳过拖拽：点击的是按钮或输入框');
                    return;
                }

                console.log('🚀 开始拖拽');

                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;

                if (e.target === header || header.contains(e.target)) {
                    isDragging = true;
                    container.classList.add('dragging');
                    e.preventDefault();
                    console.log('✅ 拖拽状态已激活');
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    xOffset = currentX;
                    yOffset = currentY;

                    const maxX = window.innerWidth - container.offsetWidth;
                    const maxY = window.innerHeight - container.offsetHeight;

                    xOffset = Math.max(0, Math.min(xOffset, maxX));
                    yOffset = Math.max(0, Math.min(yOffset, maxY));

                    container.style.transform = 'translate(' + xOffset + 'px, ' + yOffset + 'px)';

                    if (Math.random() < 0.01) {
                        console.log('📍 拖拽位置:', { xOffset, yOffset });
                    }
                }
            }

            function dragEnd() {
                if (isDragging) {
                    console.log('🏁 结束拖拽，最终位置:', { xOffset, yOffset });
                    isDragging = false;
                    container.classList.remove('dragging');
                }
            }

            header.removeEventListener('mousedown', dragStart);
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', dragEnd);

            header.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            console.log('✅ 拖拽事件监听器已添加到:', header);
        }

        let zoomTimeout = null;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let scrollStartX = 0;
        let scrollStartY = 0;

        function initPDFZoom() {
            if (!pdfCanvasContainer) return;

            pdfCanvasContainer.addEventListener('wheel', (e) => {

                if (e.ctrlKey) {
                    e.preventDefault();

                    const rect = pdfCanvasContainer.getBoundingClientRect();
                    const centerPoint = {
                        x: e.clientX - rect.left + pdfCanvasContainer.scrollLeft,
                        y: e.clientY - rect.top + pdfCanvasContainer.scrollTop
                    };

                    const factor = e.deltaY > 0 ? 0.9 : 1.1;
                    zoomPDF(factor, centerPoint);
                }
            }, { passive: false });

            pdfCanvasContainer.addEventListener('dblclick', (e) => {
                if (!isScreenshotMode && !isTextSelectionMode) {
                    e.preventDefault();

                    const rect = pdfCanvasContainer.getBoundingClientRect();
                    const centerPoint = {
                        x: e.clientX - rect.left + pdfCanvasContainer.scrollLeft,
                        y: e.clientY - rect.top + pdfCanvasContainer.scrollTop
                    };

                    const targetScale = currentScale > 1.5 ? 1.0 : 2.0;
                    const factor = targetScale / currentScale;
                    zoomPDF(factor, centerPoint);
                }
            });

            let initialDistance = 0;
            let initialScale = 1.0;

            pdfCanvasContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    initialDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );
                    initialScale = currentScale;
                }
            }, { passive: false });

            pdfCanvasContainer.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );

                    if (initialDistance > 0) {
                        const scale = (currentDistance / initialDistance) * initialScale;
                        const clampedScale = Math.max(0.1, Math.min(10.0, scale));

                        if (Math.abs(clampedScale - currentScale) > 0.1) {
                            currentScale = clampedScale;
                            renderPDFPage(currentPage);

                            if (pdfZoomLevel) {
                                pdfZoomLevel.value = Math.round(currentScale * 100) + '%';
                            }
                        }
                    }
                }
            }, { passive: false });

            pdfCanvasContainer.addEventListener('mousedown', (e) => {

                if (isScreenshotMode || e.target.tagName === 'BUTTON') return;

                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                scrollStartX = pdfCanvasContainer.scrollLeft;
                scrollStartY = pdfCanvasContainer.scrollTop;

                pdfCanvasContainer.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                e.preventDefault();

                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;

                pdfCanvasContainer.scrollLeft = scrollStartX - deltaX;
                pdfCanvasContainer.scrollTop = scrollStartY - deltaY;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    pdfCanvasContainer.style.cursor = '';
                }
            });

            console.log('✅ PDF缩放和拖拽功能已初始化');
        }

        function togglePDFSidebar() {
            if (!pdfSidebar) return;

            const isVisible = pdfSidebar.style.display !== 'none';
            pdfSidebar.style.display = isVisible ? 'none' : 'flex';

            console.log('侧边栏', isVisible ? '已隐藏' : '已显示');
            showStatus('侧边栏' + (isVisible ? '已隐藏' : '已显示'), 'info');
        }

        function switchSidebarTab(tabName) {

            document.querySelectorAll('.pdf-tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });

            document.querySelectorAll('.pdf-tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });

            const targetPanel = document.getElementById('pdf' + tabName.charAt(0).toUpperCase() + tabName.slice(1) + 'Panel');
            if (targetPanel) {
                targetPanel.classList.add('active');

                const contentElement = targetPanel.querySelector('[id$="List"]');
                if (contentElement) {
                    console.log('标签页内容元素:', {
                        id: contentElement.id,
                        scrollHeight: contentElement.scrollHeight,
                        clientHeight: contentElement.clientHeight,
                        overflowY: getComputedStyle(contentElement).overflowY
                    });
                }
            }

            console.log('切换到标签:', tabName);

            setTimeout(refreshScrolling, 100);
        }

        async function performSidebarSearch() {
            const searchTerm = pdfSidebarSearch.value.trim();
            if (!searchTerm) {
                pdfSearchResultsList.innerHTML = '请输入搜索关键词';
                return;
            }

            await performPDFSearch(searchTerm);
        }

        async function loadPDFOutline() {
            if (!currentPDF || !pdfOutlineList) return;

            try {
                const outline = await currentPDF.getOutline();

                if (!outline || outline.length === 0) {
                    pdfOutlineList.innerHTML = '<div style="color: #666; font-style: italic;">此PDF没有目录</div>';
                    return;
                }

                const outlineData = [];

                let outlineItemCounter = 0;

                async function flattenOutlineItem(item, level = 1) {
                    const title = item.title || '无标题';
                    const dest = item.dest;
                    outlineItemCounter++;

                    let page = outlineItemCounter;

                    try {
                        if (dest && currentPDF) {
                            if (typeof dest === 'string') {

                                const destArray = await currentPDF.getDestination(dest);
                                if (destArray && destArray[0]) {
                                    const pageIndex = await currentPDF.getPageIndex(destArray[0]);
                                    page = pageIndex + 1;
                                }
                            } else if (Array.isArray(dest) && dest[0]) {

                                const pageIndex = await currentPDF.getPageIndex(dest[0]);
                                page = pageIndex + 1;
                            } else if (dest && dest[0] && dest[0].num) {

                                const potentialPage = dest[0].num;
                                if (potentialPage > 0 && potentialPage <= 1000) {
                                    page = potentialPage;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('无法获取目录项页码:', title, e);

                    }

                    outlineData.push({
                        title: '  '.repeat(level - 1) + '📄 ' + title,
                        page: page,
                        level: level,
                        dest: dest
                    });

                    if (item.items && item.items.length > 0) {
                        for (const subItem of item.items) {
                            await flattenOutlineItem(subItem, level + 1);
                        }
                    }
                }

                for (const item of outline) {
                    await flattenOutlineItem(item);
                }

                setupPagination('outline', outlineData, renderOutlinePage);
                console.log('PDF目录加载完成，共', outlineData.length, '项');

                console.log('目录页码示例:', outlineData.slice(0, 5).map(item => ({
                    title: item.title.trim(),
                    page: item.page,
                    level: item.level
                })));

                setTimeout(refreshScrolling, 100);

            } catch (error) {
                console.error('加载PDF目录失败:', error);
                pdfOutlineList.innerHTML = '<div style="color: #dc3545;">目录加载失败</div>';
            }
        }

        async function navigateToOutlineItem(destStr, fallbackPage = 1) {
            try {
                const dest = JSON.parse(destStr);
                if (!dest || !currentPDF) {

                    renderPDFPage(fallbackPage);
                    showStatus('已跳转到第 ' + fallbackPage + ' 页', 'success');
                    return;
                }

                const destRef = await currentPDF.getDestination(dest);
                if (destRef) {
                    const pageRef = destRef[0];
                    const pageIndex = await currentPDF.getPageIndex(pageRef);
                    const pageNum = pageIndex + 1;

                    renderPDFPage(pageNum);
                    showStatus('已跳转到第 ' + pageNum + ' 页', 'success');
                } else {

                    renderPDFPage(fallbackPage);
                    showStatus('已跳转到第 ' + fallbackPage + ' 页', 'success');
                }
            } catch (error) {
                console.error('导航失败:', error);

                renderPDFPage(fallbackPage);
                showStatus('已跳转到第 ' + fallbackPage + ' 页', 'warning');
            }
        }

        async function performPDFSearchOld() {
            const searchTerm = document.getElementById('pdfSidebarSearch')?.value.trim() || '';
            if (!searchTerm) {
                showStatus('请输入搜索内容', 'warning');
                return;
            }

            if (!currentPDF) {
                showStatus('请先加载PDF文档', 'error');
                return;
            }

            showStatus('正在搜索...', 'info');
            console.log('搜索PDF内容:', searchTerm);

            try {
                let foundResults = [];

                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    const page = await currentPDF.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    const pageText = textContent.items.map(item => item.str).join(' ');

                    const regex = new RegExp(searchTerm, 'gi');
                    const matches = [...pageText.matchAll(regex)];

                    if (matches.length > 0) {
                        foundResults.push({
                            page: pageNum,
                            matches: matches.length,
                            text: pageText
                        });
                    }
                }

                if (foundResults.length > 0) {

                    const firstResult = foundResults[0];
                    renderPDFPage(firstResult.page);

                    showStatus('找到 ' + foundResults.length + ' 页包含"' + searchTerm + '"，已跳转到第 ' + firstResult.page + ' 页', 'success');
                    console.log('搜索结果:', foundResults);
                } else {
                    showStatus('未找到"' + searchTerm + '"', 'warning');
                }

            } catch (error) {
                console.error('搜索失败:', error);
                showStatus('搜索失败', 'error');
            }
        }

        function handlePDFError(error, context = '') {
            console.error(`PDF错误 [${context}]:`, error);
            setPDFState(PDFState.ERROR);

            let errorMessage = '未知错误';
            if (error.name === 'InvalidPDFException') {
                errorMessage = '无效的PDF文件格式';
            } else if (error.name === 'MissingPDFException') {
                errorMessage = 'PDF文件损坏或缺失';
            } else if (error.name === 'UnexpectedResponseException') {
                errorMessage = 'PDF文件加载失败';
            } else if (error.message) {
                errorMessage = error.message;
            }

            showStatus(`PDF加载失败: ${errorMessage}`, 'error');

            currentPDF = null;
            currentPDFFile = null;
            currentPDFFileName = '';
            totalPages = 0;
            currentPage = 1;
            currentScale = 1.0;

            logPDFStatus('错误处理后清理');
        }

        async function openPDFViewer(file, fileName) {
            console.log('=== 开始打开PDF预览器 ===');
            console.log('文件信息:', {
                name: file.name,
                size: file.size,
                type: file.type
            });

            try {

                setPDFState(PDFState.LOADING, 10);

                currentPDFFile = file;
                currentPDFFileName = fileName || file.name || 'PDF文档';

                console.log('设置PDF文件变量:', {
                    currentPDFFile: !!currentPDFFile,
                    currentPDFFileName
                });

                if (!pdfViewerContainer) {
                    throw new Error('PDF预览器容器未找到');
                }

                pdfViewerTitle.textContent = currentPDFFileName + ' - 加载中...';
                pdfViewerContainer.classList.add('active');

                console.log('PDF预览器容器已激活');
                setPDFState(PDFState.LOADING, 20);

                if (typeof pdfjsLib === 'undefined') {
                    throw new Error('PDF.js库未加载');
                }

                console.log('开始读取PDF文件...');
                setPDFState(PDFState.LOADING, 30);

                const arrayBuffer = await file.arrayBuffer();
                console.log('PDF文件读取完成，大小:', arrayBuffer.byteLength);
                setPDFState(PDFState.LOADING, 50);

                const loadingTask = pdfjsLib.getDocument(arrayBuffer);

                loadingTask.onProgress = function(progress) {
                    if (progress.total > 0) {
                        const percent = Math.round((progress.loaded / progress.total) * 30) + 50;
                        setPDFState(PDFState.LOADING, Math.min(percent, 80));
                    }
                };

                currentPDF = await loadingTask.promise;
                console.log('PDF文档加载成功');
                setPDFState(PDFState.LOADING, 85);

                totalPages = currentPDF.numPages;
                currentPage = 1;
                currentScale = 1.0;

                console.log('PDF基本信息:', {
                    totalPages,
                    currentPage,
                    currentScale
                });

                if (!pdfCanvas) {
                    throw new Error('PDF canvas元素未找到');
                }

                pdfContext = pdfCanvas.getContext('2d');
                console.log('PDF canvas初始化完成');

                updatePDFPageInfo();

                console.log('开始渲染第一页...');
                setPDFState(PDFState.RENDERING, 90);
                await renderPDFPage(currentPage);

                updatePDFControls();

                initPDFDragging();

                initPDFZoom();

                loadPDFOutline();

                setPDFState(PDFState.LOADING, 95);

                if (pdfTextSelect) {
                    if (isTextSelectionMode) {
                        pdfTextSelect.style.backgroundColor = '#28a745';
                        pdfTextSelect.style.color = 'white';
                        if (pdfCanvas) {
                            pdfCanvas.style.cursor = 'text';
                            pdfCanvas.style.userSelect = 'text';
                        }

                        if (pdfTextLayer) {
                            pdfTextLayer.classList.add('enabled');
                            pdfTextLayer.style.pointerEvents = 'auto';
                        }
                    } else {

                        pdfTextSelect.style.backgroundColor = '';
                        pdfTextSelect.style.color = '';
                        if (pdfCanvas) {
                            pdfCanvas.style.cursor = 'default';
                            pdfCanvas.style.userSelect = 'none';
                        }

                        if (pdfTextLayer) {
                            pdfTextLayer.classList.remove('enabled');
                            pdfTextLayer.style.pointerEvents = 'none';
                        }
                    }
                }

                pdfViewerTitle.textContent = currentPDFFileName;

                initMoreOptionsMenu();

                setPDFState(PDFState.READY, 100);

                console.log('✅ PDF预览器打开成功');
                showStatus('PDF文件 "' + currentPDFFileName + '" 加载成功', 'success');

                logPDFStatus('PDF加载完成后');

                updatePDFStatusIndicator();

            } catch (error) {
                handlePDFError(error, 'openPDFViewer');
            }
        }

        let currentRenderTask = null;

        async function addToRenderQueue(pageNum) {
            return new Promise((resolve, reject) => {
                renderQueue.push({ pageNum, resolve, reject });
                processRenderQueue();
            });
        }

        async function processRenderQueue() {
            if (isRenderingInProgress || renderQueue.length === 0) return;

            isRenderingInProgress = true;
            const { pageNum, resolve, reject } = renderQueue.shift();

            try {
                await renderPDFPageInternal(pageNum);
                resolve();
            } catch (error) {
                reject(error);
            } finally {
                isRenderingInProgress = false;

                if (renderQueue.length > 0) {
                    setTimeout(processRenderQueue, 10);
                }
            }
        }

        async function renderPDFPage(pageNum) {
            if (!currentPDF) return;

            currentViewingPage = pageNum;

            renderQueue.length = 0;

            return addToRenderQueue(pageNum);
        }

        async function renderPDFPageInternal(pageNum) {
            if (!currentPDF) return;

            const renderStartTime = performance.now();

            if (currentRenderTask) {
                try {
                    currentRenderTask.cancel();
                    console.log('📄 取消之前的渲染任务');
                } catch (e) {
                    console.log('📄 渲染任务取消失败:', e);
                }
                currentRenderTask = null;
            }

            try {
                setPDFState(PDFState.RENDERING);

                const page = await currentPDF.getPage(pageNum);

                const originalRotation = page.rotate || 0;
                if (originalRotation !== 0) {
                    console.log(`页面 ${pageNum} 原始旋转: ${originalRotation}度 (已忽略，仅使用用户旋转: ${userRotation}度)`);
                } else {
                    console.log(`页面 ${pageNum} 无原始旋转，用户旋转: ${userRotation}度`);
                }

                const baseViewport = page.getViewport({
                    scale: currentScale,
                    rotation: 0
                });

                const viewport = handlePDFRotation(page, baseViewport);

                const hwSettings = HardwareCapabilities.getOptimalRenderSettings();

                if (currentScale > hwSettings.maxScale) {
                    console.warn(`当前缩放 ${currentScale.toFixed(1)}x 超过硬件限制 ${hwSettings.maxScale}x，可能影响性能`);
                    showStatus(`缩放过大可能影响性能，建议不超过 ${hwSettings.maxScale}x`, 'warning');
                }

                pdfCanvas.width = viewport.width;
                pdfCanvas.height = viewport.height;
                pdfCanvas.style.width = viewport.width + 'px';
                pdfCanvas.style.height = viewport.height + 'px';

                const pdfCanvasContent = document.getElementById('pdfCanvasContent');
                if (pdfCanvasContent) {
                    pdfCanvasContent.style.width = viewport.width + 'px';
                    pdfCanvasContent.style.height = viewport.height + 'px';
                }

                pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);

                const renderContext = {
                    canvasContext: pdfContext,
                    viewport: viewport,
                    intent: 'display',
                    enableWebGL: hwSettings.enableWebGL,
                    renderInteractiveForms: false,

                    transform: null
                };

                currentRenderTask = page.render(renderContext);
                await currentRenderTask.promise;
                currentRenderTask = null;

                await renderTextLayer(page, viewport);

                currentPage = pageNum;
                updatePDFPageInfo();
                updatePDFControls();

                setPDFState(PDFState.READY);

                PDFPerformanceMonitor.recordRenderTime(renderStartTime);

            } catch (error) {

                if (error.name === 'RenderingCancelledException') {
                    console.log('📄 PDF渲染已取消（正常）');
                } else {
                    console.error('PDF页面渲染失败:', error);
                    handlePDFError(error, 'renderPDFPageInternal');
                }
            }
        }

        let userRotation = 0;

        function handlePDFRotation(page, baseViewport) {

            if (userRotation !== 0) {
                console.log(`应用用户旋转: ${userRotation}度`);

                return page.getViewport({
                    scale: currentScale,
                    rotation: userRotation
                });
            }

            return page.getViewport({
                scale: currentScale,
                rotation: 0
            });
        }

        async function rotatePDF(degrees) {
            const oldRotation = userRotation;
            userRotation = (userRotation + degrees) % 360;
            if (userRotation < 0) userRotation += 360;

            console.log(`用户手动旋转PDF: ${degrees}度, 从 ${oldRotation}度 到 ${userRotation}度`);

            await renderPDFPage(currentPage);

            const rotationText = userRotation === 0 ? '正常' : `${userRotation}度`;
            showStatus(`PDF已旋转 ${degrees > 0 ? '顺时针' : '逆时针'} ${Math.abs(degrees)}度，当前角度: ${rotationText}`, 'info');
        }

        async function resetPDFRotation() {
            if (userRotation === 0) {
                showStatus('PDF已经是正常显示角度', 'info');
                return;
            }

            const oldRotation = userRotation;
            userRotation = 0;
            console.log(`重置PDF旋转: 从 ${oldRotation}度 重置为 0度`);

            await renderPDFPage(currentPage);
            showStatus('PDF旋转已重置为正常显示', 'success');
        }

        function getPageRotationInfo(page) {
            const originalRotation = page.rotate || 0;
            console.log(`页面原始旋转: ${originalRotation}度, 用户旋转: ${userRotation}度`);
            return {
                original: originalRotation,
                user: userRotation,
                display: userRotation
            };
        }

        async function renderTextLayer(page, viewport) {
            if (!pdfTextLayer) return;

            try {

                pdfTextLayer.innerHTML = '';

                const adjustedViewport = handlePDFRotation(page, viewport);

                pdfTextLayer.style.width = adjustedViewport.width + 'px';
                pdfTextLayer.style.height = adjustedViewport.height + 'px';
                pdfTextLayer.style.setProperty('--scale-factor', adjustedViewport.scale);

                const textContent = await page.getTextContent({
                    normalizeWhitespace: true,
                    disableCombineTextItems: false
                });

                if (window.pdfjsLib && window.pdfjsLib.renderTextLayer) {

                    const textLayerRenderTask = window.pdfjsLib.renderTextLayer({
                        textContentSource: textContent,
                        container: pdfTextLayer,
                        viewport: viewport,
                        textDivs: [],

                        enhanceTextSelection: true
                    });

                    await textLayerRenderTask.promise;
                } else {

                    const fragment = document.createDocumentFragment();

                    textContent.items.forEach((textItem, index) => {
                        if (!textItem.str || textItem.str.trim() === '') return;

                        const textDiv = document.createElement('span');
                        textDiv.textContent = textItem.str;
                        textDiv.setAttribute('data-text-index', index);

                        const transform = textItem.transform;
                        const x = transform[4];
                        const y = transform[5];
                        const fontSize = Math.sqrt(transform[0] * transform[0] + transform[1] * transform[1]);

                        textDiv.style.cssText = `
                            position: absolute;
                            left: ${x}px;
                            top: ${viewport.height - y}px;
                            font-size: ${fontSize}px;
                            font-family: ${textItem.fontName || 'sans-serif'};
                            transform-origin: 0% 0%;
                            white-space: pre;
                            color: transparent;
                            user-select: text;
                        `;

                        fragment.appendChild(textDiv);
                    });

                    pdfTextLayer.appendChild(fragment);
                }

                updateTextLayerMode();

                console.log('文本层渲染完成，文本选择模式:', isTextSelectionMode, '文本项数量:', textContent.items.length);
            } catch (error) {
                console.error('渲染文本层失败:', error);

                showStatus('文本层渲染失败，文本选择功能可能不可用', 'warning');
            }
        }

        function updateTextLayerMode() {
            if (!pdfTextLayer) return;

            if (isTextSelectionMode) {
                pdfTextLayer.classList.add('enabled');
                pdfTextLayer.style.pointerEvents = 'auto';
                pdfTextLayer.style.userSelect = 'text';
            } else {
                pdfTextLayer.classList.remove('enabled');
                pdfTextLayer.style.pointerEvents = 'none';
                pdfTextLayer.style.userSelect = 'none';
            }
        }

        function updatePDFPageInfo() {
            if (pdfPageInput) pdfPageInput.value = currentPage;
            if (pdfTotalPages) pdfTotalPages.textContent = totalPages;

            if (pdfZoomLevel) {
                pdfZoomLevel.value = Math.round(currentScale * 100) + '%';
            }

            updatePDFControls();

            updatePDFStatusIndicator();
        }

        function updatePDFControls() {
            pdfPrevPage.disabled = currentPage <= 1;
            pdfNextPage.disabled = currentPage >= totalPages;
        }

        async function changePDFPage(delta) {
            const newPage = currentPage + delta;
            if (newPage >= 1 && newPage <= totalPages) {
                await renderPDFPage(newPage);
            }
        }

        async function zoomPDF(factor, centerPoint = null) {

            const container = pdfCanvasContainer;
            const scrollLeft = container.scrollLeft;
            const scrollTop = container.scrollTop;
            const oldScale = currentScale;

            const hwSettings = HardwareCapabilities.getOptimalRenderSettings();
            const maxScale = hwSettings.maxScale;
            const minScale = 0.1;

            currentScale *= factor;
            currentScale = Math.max(minScale, Math.min(maxScale, currentScale));

            if (currentScale === maxScale && factor > 1) {
                showStatus(`已达到最大缩放 ${Math.round(maxScale * 100)}%（受硬件性能限制）`, 'warning');
            } else if (currentScale === minScale && factor < 1) {
                showStatus(`已达到最小缩放 ${Math.round(minScale * 100)}%`, 'info');
            }

            if (pdfZoomLevel) {
                pdfZoomLevel.value = Math.round(currentScale * 100) + '%';
            }

            await renderPDFPage(currentPage);

            if (centerPoint) {

                const scaleRatio = currentScale / oldScale;
                const newScrollLeft = centerPoint.x * scaleRatio - container.clientWidth / 2;
                const newScrollTop = centerPoint.y * scaleRatio - container.clientHeight / 2;

                container.scrollLeft = Math.max(0, newScrollLeft);
                container.scrollTop = Math.max(0, newScrollTop);
            } else {

                const scaleRatio = currentScale / oldScale;
                const centerX = scrollLeft + container.clientWidth / 2;
                const centerY = scrollTop + container.clientHeight / 2;

                const newScrollLeft = centerX * scaleRatio - container.clientWidth / 2;
                const newScrollTop = centerY * scaleRatio - container.clientHeight / 2;

                container.scrollLeft = Math.max(0, newScrollLeft);
                container.scrollTop = Math.max(0, newScrollTop);
            }

            console.log('缩放完成:', {
                oldScale: oldScale.toFixed(2),
                newScale: currentScale.toFixed(2),
                factor: factor.toFixed(2)
            });
        }

        async function fitPDFWidth() {
            if (!currentPDF) return;

            const page = await currentPDF.getPage(currentPage);
            const viewport = page.getViewport({ scale: 1.0 });
            const containerWidth = pdfCanvasContainer.clientWidth - 40;

            currentScale = containerWidth / viewport.width;
            await renderPDFPage(currentPage);

            pdfCanvasContainer.scrollTop = 0;
            pdfCanvasContainer.scrollLeft = 0;

            console.log('适应宽度完成:', {
                containerWidth: containerWidth,
                viewportWidth: viewport.width,
                scale: currentScale.toFixed(2)
            });
        }

        async function fitPDFPage() {
            if (!currentPDF) return;

            const page = await currentPDF.getPage(currentPage);
            const viewport = page.getViewport({ scale: 1.0 });
            const containerWidth = pdfCanvasContainer.clientWidth - 40;
            const containerHeight = pdfCanvasContainer.clientHeight - 40;

            const scaleX = containerWidth / viewport.width;
            const scaleY = containerHeight / viewport.height;
            currentScale = Math.min(scaleX, scaleY);

            await renderPDFPage(currentPage);

            pdfCanvasContainer.scrollTop = 0;
            pdfCanvasContainer.scrollLeft = 0;

            console.log('适应页面完成:', {
                containerWidth: containerWidth,
                containerHeight: containerHeight,
                viewportWidth: viewport.width,
                viewportHeight: viewport.height,
                scaleX: scaleX.toFixed(2),
                scaleY: scaleY.toFixed(2),
                finalScale: currentScale.toFixed(2)
            });
        }

        function closePDFViewer() {
            console.log('⚠️ closePDFViewer 被调用 - 仅关闭预览器，保留PDF状态');
            console.trace('调用堆栈:');

            pdfViewerContainer.classList.remove('active');

            currentPage = 1;
            currentScale = 1.0;

            clearPDFSelection();

            pdfAnnotations = [];
            pdfBookmarks = [];
            updatePDFAnnotationsList();
            updatePDFBookmarksList();

            if (reopenPDFBtn && currentPDF && currentPDFFile) {
                reopenPDFBtn.style.display = 'inline-block';
            }

            logPDFStatus('closePDFViewer执行后（保留PDF状态）');
            showStatus('PDF预览器已关闭，PDF文件仍可用于分析。点击"重新打开"可恢复预览', 'info');

            updatePDFStatusIndicator();
        }

        async function getCurrentPDFFile() {
            console.log('getCurrentPDFFile 调用:', {
                currentPDFFile: !!currentPDFFile,
                currentPDFFileName,
                fileSize: currentPDFFile ? currentPDFFile.size : 0
            });

            if (!currentPDFFile) {
                console.log('getCurrentPDFFile: currentPDFFile 为空');
                return null;
            }

            try {

                const newFile = new File([currentPDFFile], currentPDFFileName, {
                    type: 'application/pdf',
                    lastModified: Date.now()
                });

                console.log('getCurrentPDFFile: 成功创建新文件对象:', {
                    name: newFile.name,
                    size: newFile.size,
                    type: newFile.type
                });

                return newFile;
            } catch (error) {
                console.error('getCurrentPDFFile: 创建文件对象失败:', error);
                return null;
            }
        }

        function toggleTextSelectionMode() {
            isTextSelectionMode = !isTextSelectionMode;

            if (isTextSelectionMode) {

                if (isScreenshotMode) {
                    isScreenshotMode = false;
                    pdfScreenshot.textContent = '📷';
                    pdfScreenshot.title = '切换PDF截图模式';
                    pdfScreenshot.style.backgroundColor = '';
                    pdfScreenshot.style.color = '';
                    clearPDFSelection();
                }

                pdfTextSelect.textContent = '📝';
                pdfTextSelect.title = '文本选择模式（已激活）';
                pdfTextSelect.style.backgroundColor = '#28a745';
                pdfTextSelect.style.color = 'white';

                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'text';
                    pdfCanvas.style.userSelect = 'text';
                }

                if (pdfCanvasContainer) {
                    pdfCanvasContainer.style.cursor = 'text';
                }

                if (pdfTextLayer) {
                    pdfTextLayer.classList.add('enabled');
                    pdfTextLayer.style.pointerEvents = 'auto';
                }

                hideHighlightToolbar();

                showStatus('文本选择模式已激活，可以选择和复制PDF文本', 'info');
                console.log('📝 文本选择模式已激活');

                if (pdfTextLayer) {
                    console.log('文本层状态:', {
                        enabled: pdfTextLayer.classList.contains('enabled'),
                        pointerEvents: pdfTextLayer.style.pointerEvents,
                        childCount: pdfTextLayer.children.length
                    });
                }
            } else {
                pdfTextSelect.textContent = '📝';
                pdfTextSelect.title = '文本选择模式';
                pdfTextSelect.style.backgroundColor = '';
                pdfTextSelect.style.color = '';

                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'default';
                    pdfCanvas.style.userSelect = 'none';
                }

                if (pdfCanvasContainer) {
                    pdfCanvasContainer.style.cursor = 'grab';
                }

                if (pdfTextLayer) {
                    pdfTextLayer.classList.remove('enabled');
                    pdfTextLayer.style.pointerEvents = 'none';
                }

                if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                }
                hideHighlightToolbar();
                currentSelection = null;
                currentSelectedText = '';

                showStatus('文本选择模式已关闭', 'info');
                console.log('📝 文本选择模式已关闭');
            }

            updatePDFStatusIndicator();
        }

        function toggleScreenshotMode() {
            isScreenshotMode = !isScreenshotMode;

            if (isScreenshotMode) {

                if (isTextSelectionMode) {
                    isTextSelectionMode = false;
                    pdfTextSelect.textContent = '📝';
                    pdfTextSelect.title = '文本选择模式';
                    pdfTextSelect.style.backgroundColor = '';
                    pdfTextSelect.style.color = '';

                    if (window.getSelection) {
                        window.getSelection().removeAllRanges();
                    }
                    hideHighlightToolbar();
                    currentSelection = null;
                    currentSelectedText = '';
                }

                pdfScreenshot.textContent = '🚫';
                pdfScreenshot.title = '退出PDF截图模式';
                pdfScreenshot.style.backgroundColor = '#dc3545';
                pdfScreenshot.style.color = 'white';

                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'crosshair';
                    pdfCanvas.style.userSelect = 'none';
                }

                if (pdfCanvasContainer) {
                    pdfCanvasContainer.style.cursor = 'crosshair';
                }

                if (pdfTextLayer) {
                    pdfTextLayer.classList.remove('enabled');
                    pdfTextLayer.style.pointerEvents = 'none';
                }

                showStatus('截图模式已激活，在PDF上拖拽选择区域进行截图', 'info');
                console.log('📷 截图模式已激活');
            } else {
                pdfScreenshot.textContent = '📷';
                pdfScreenshot.title = '切换PDF截图模式';
                pdfScreenshot.style.backgroundColor = '';
                pdfScreenshot.style.color = '';

                if (pdfCanvas) {
                    pdfCanvas.style.cursor = 'default';
                    pdfCanvas.style.userSelect = 'none';
                }

                if (pdfCanvasContainer) {
                    pdfCanvasContainer.style.cursor = 'grab';
                }

                clearPDFSelection();

                showStatus('截图模式已关闭', 'info');
                console.log('📷 截图模式已关闭');
            }

            updatePDFStatusIndicator();
        }

        function toggleTextLayerDebug() {
            if (!pdfTextLayer) {
                showStatus('文本层不存在', 'error');
                return;
            }

            const isDebug = pdfTextLayer.classList.contains('debug');

            if (isDebug) {
                pdfTextLayer.classList.remove('debug');
                pdfDebugText.style.backgroundColor = '';
                pdfDebugText.style.color = '';
                showStatus('调试模式已关闭', 'info');
            } else {
                pdfTextLayer.classList.add('debug');
                pdfDebugText.style.backgroundColor = '#ffc107';
                pdfDebugText.style.color = 'black';
                showStatus('调试模式已开启', 'info');

                const container = document.getElementById('pdfCanvasContainer');
                const wrapper = document.getElementById('pdfCanvasWrapper');
                const content = document.getElementById('pdfCanvasContent');
                const canvas = document.getElementById('pdfCanvas');

                console.log('PDF布局调试信息:', {
                    container: {
                        clientWidth: container.clientWidth,
                        clientHeight: container.clientHeight,
                        scrollLeft: container.scrollLeft,
                        scrollTop: container.scrollTop,
                        scrollWidth: container.scrollWidth,
                        scrollHeight: container.scrollHeight
                    },
                    wrapper: wrapper ? {
                        offsetWidth: wrapper.offsetWidth,
                        offsetHeight: wrapper.offsetHeight,
                        style: wrapper.style.cssText
                    } : 'null',
                    content: content ? {
                        offsetWidth: content.offsetWidth,
                        offsetHeight: content.offsetHeight,
                        style: content.style.cssText
                    } : 'null',
                    canvas: canvas ? {
                        width: canvas.width,
                        height: canvas.height,
                        styleWidth: canvas.style.width,
                        styleHeight: canvas.style.height,
                        offsetLeft: canvas.offsetLeft,
                        offsetTop: canvas.offsetTop
                    } : 'null',
                    currentScale: currentScale,
                    textLayer: {
                        childCount: pdfTextLayer.children.length,
                        enabled: pdfTextLayer.classList.contains('enabled'),
                        pointerEvents: pdfTextLayer.style.pointerEvents,
                        opacity: pdfTextLayer.style.opacity
                    }
                });
            }
        }

        function highlightSelectedText() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0 && selection.toString().trim()) {
                const selectedText = selection.toString().trim();
                console.log('高亮文本:', selectedText);

                const annotation = {
                    id: Date.now(),
                    type: 'highlight',
                    text: selectedText,
                    page: currentPage,
                    timestamp: new Date().toLocaleString(),
                    color: '#ffff00'
                };

                pdfAnnotations.push(annotation);
                updatePDFAnnotationsList();

                showStatus('已高亮文本: "' + selectedText.substring(0, 30) + (selectedText.length > 30 ? '...' : '') + '"', 'success');

                selection.removeAllRanges();
            } else {
                showStatus('请先选择要高亮的文本', 'warning');
            }
        }

        function updatePDFAnnotationsList() {

            setupPagination('annotations', pdfAnnotations, renderAnnotationsPage);

            setTimeout(refreshScrolling, 100);
        }

        function removeAnnotation(annotationId) {
            pdfAnnotations = pdfAnnotations.filter(ann => ann.id !== annotationId);
            updatePDFAnnotationsList();
            showStatus('注释已删除', 'success');
        }

        function showPageUploadDialog() {
            if (!currentPDF) {
                showStatus('没有可上传的PDF文件', 'error');
                return;
            }

            document.getElementById('currentPageNum').textContent = currentPage;
            document.getElementById('totalPageNum').textContent = totalPages;
            document.getElementById('startPage').max = totalPages;
            document.getElementById('endPage').max = totalPages;
            document.getElementById('startPage').value = currentPage;
            document.getElementById('endPage').value = currentPage;

            document.getElementById('pageUploadDialog').style.display = 'flex';
        }

        function closePageUploadDialog() {
            document.getElementById('pageUploadDialog').style.display = 'none';
        }

        async function confirmPageUpload() {
            const uploadType = document.querySelector('input[name="uploadType"]:checked').value;
            const outputFormat = document.querySelector('input[name="outputFormat"]:checked').value;
            const uploadToChat = document.getElementById('uploadPagesToChat').checked;
            const saveToLocal = document.getElementById('savePagesToLocal').checked;

            if (!uploadToChat && !saveToLocal) {
                showStatus('请至少选择一种处理方式', 'error');
                return;
            }

            try {
                if (uploadType === 'current') {

                    await uploadCurrentPage(outputFormat, uploadToChat, saveToLocal);
                } else {

                    const startPage = parseInt(document.getElementById('startPage').value);
                    const endPage = parseInt(document.getElementById('endPage').value);

                    if (startPage > endPage) {
                        showStatus('起始页面不能大于结束页面', 'error');
                        return;
                    }

                    if (startPage < 1 || endPage > totalPages) {
                        showStatus('页面范围超出文档范围', 'error');
                        return;
                    }

                    await uploadPageRange(startPage, endPage, outputFormat, uploadToChat, saveToLocal);
                }

                closePageUploadDialog();
            } catch (error) {
                console.error('页面处理失败:', error);
                showStatus('页面处理失败', 'error');
            }
        }

        async function uploadCurrentPage(outputFormat = 'pdf', uploadToChat = true, saveToLocal = false) {
            if (outputFormat === 'pdf') {
                showStatus('正在生成当前页面PDF...', 'info');

                try {

                    const { PDFDocument } = PDFLib;
                    const newPdfDoc = await PDFDocument.create();

                    const existingPdfBytes = await currentPDFFile.arrayBuffer();
                    const existingPdfDoc = await PDFDocument.load(existingPdfBytes);

                    const [copiedPage] = await newPdfDoc.copyPages(existingPdfDoc, [currentPage - 1]);
                    newPdfDoc.addPage(copiedPage);

                    const pdfBytes = await newPdfDoc.save();

                    const fileName = currentPDFFileName.replace('.pdf', '') + '_第' + currentPage + '页.pdf';
                    const file = new File([pdfBytes], fileName, { type: 'application/pdf' });

                    if (saveToLocal) {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(file);
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                        console.log('📄 PDF页面已保存到本地:', fileName);
                    }

                    if (uploadToChat) {

                        uploadedFiles.push(file);

                        const fileId = 'page_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        addFilePreview(file, fileId);

                        uploadFile(file, fileId);

                        updateAttachmentIndicator();
                    }

                    let statusMessage = '当前页面PDF处理完成';
                    if (uploadToChat && saveToLocal) {
                        statusMessage = '当前页面PDF已添加到附件并保存到本地';
                    } else if (uploadToChat) {
                        statusMessage = '当前页面PDF已添加到附件';
                    } else if (saveToLocal) {
                        statusMessage = '当前页面PDF已保存到本地';
                    }
                    showStatus(statusMessage, 'success');

                } catch (error) {
                    console.error('PDF生成失败:', error);
                    showStatus('PDF生成失败，请重试', 'error');
                }
            } else {

                showStatus('正在生成当前页面图片...', 'info');

                const page = await currentPDF.getPage(currentPage);
                const viewport = page.getViewport({ scale: 2.0 });

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;

                await page.render({
                    canvasContext: tempCtx,
                    viewport: viewport
                }).promise;

                tempCanvas.toBlob(async (blob) => {
                    const fileName = currentPDFFileName.replace('.pdf', '') + '_第' + currentPage + '页.png';
                    const file = new File([blob], fileName, { type: 'image/png' });

                    uploadedFiles.push(file);

                    const fileId = 'page_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    addFilePreview(file, fileId);

                    uploadFile(file, fileId);

                    updateAttachmentIndicator();

                    showStatus('当前页面图片已添加到附件', 'success');
                }, 'image/png', 0.9);
            }
        }

        async function uploadPageRange(startPage, endPage, outputFormat = 'pdf') {
            if (outputFormat === 'pdf') {
                showStatus('正在生成PDF页面范围 ' + startPage + '-' + endPage + '...', 'info');

                try {

                    const { PDFDocument } = PDFLib;
                    const newPdfDoc = await PDFDocument.create();

                    const existingPdfBytes = await currentPDFFile.arrayBuffer();
                    const existingPdfDoc = await PDFDocument.load(existingPdfBytes);

                    const pageIndices = [];
                    for (let i = startPage - 1; i < endPage; i++) {
                        pageIndices.push(i);
                    }

                    const copiedPages = await newPdfDoc.copyPages(existingPdfDoc, pageIndices);

                    copiedPages.forEach((page) => {
                        newPdfDoc.addPage(page);
                    });

                    const pdfBytes = await newPdfDoc.save();

                    const fileName = currentPDFFileName.replace('.pdf', '') + '_第' + startPage + '-' + endPage + '页.pdf';
                    const file = new File([pdfBytes], fileName, { type: 'application/pdf' });

                    uploadedFiles.push(file);

                    const fileId = 'pages_' + startPage + '_' + endPage + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    addFilePreview(file, fileId);

                    uploadFile(file, fileId);

                    updateAttachmentIndicator();
                    showStatus('PDF页面范围 ' + startPage + '-' + endPage + ' 已添加到附件', 'success');

                } catch (error) {
                    console.error('PDF页面范围生成失败:', error);
                    showStatus('PDF生成失败，请重试', 'error');
                }
            } else {

                showStatus('正在生成页面范围图片 ' + startPage + '-' + endPage + '...', 'info');

                for (let pageNum = startPage; pageNum <= endPage; pageNum++) {
                    await uploadSinglePageAsImage(pageNum);
                }

                updateAttachmentIndicator();
                showStatus('页面范围图片 ' + startPage + '-' + endPage + ' 已添加到附件', 'success');
            }
        }

        async function uploadSinglePageAsImage(pageNum) {
            const page = await currentPDF.getPage(pageNum);
            const viewport = page.getViewport({ scale: 2.0 });

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;

            await page.render({
                canvasContext: tempCtx,
                viewport: viewport
            }).promise;

            return new Promise((resolve) => {
                tempCanvas.toBlob(async (blob) => {
                    const fileName = currentPDFFileName.replace('.pdf', '') + '_第' + pageNum + '页.png';
                    const file = new File([blob], fileName, { type: 'image/png' });

                    uploadedFiles.push(file);

                    const fileId = 'page_' + pageNum + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    addFilePreview(file, fileId);

                    uploadFile(file, fileId);

                    resolve();
                }, 'image/png', 0.9);
            });
        }

        function downloadPDF() {
            if (!currentPDFFile) {
                showStatus('没有可下载的PDF文件', 'error');
                return;
            }

            try {
                const url = URL.createObjectURL(currentPDFFile);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentPDFFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showStatus('PDF文件 "' + currentPDFFileName + '" 下载完成', 'success');

            } catch (error) {
                console.error('下载失败:', error);
                showStatus('下载失败', 'error');
            }
        }

        function showPDFHelp() {
            const helpContent = `
📖 PDF预览器快捷键帮助

🔧 基本操作：
• ←→ 或 Ctrl+↑↓：翻页
• ↑↓：滚动页面
• Page Up/Down：翻页（+Ctrl）或滚动
• Home/End：跳转首页/末页（+Ctrl）或滚动到顶部/底部
• Ctrl+滚轮：以鼠标为中心缩放
• 双击：在100%和200%之间切换缩放

⚡ 功能快捷键：
• S：切换截图模式 📷
• T：切换文本选择模式 📝
• H：高亮选中文本 🖍️
• R：顺时针旋转90度 ↻
• Shift+R：逆时针旋转90度 ↺
• Ctrl+R：重置旋转 🔄
• Ctrl+F：聚焦URL输入框 🌐
• Ctrl+M：最小化/还原预览器
• Esc：关闭预览器或退出当前模式

🔍 缩放快捷键：
• +/=：放大 (120%)
• -：缩小 (80%)
• Ctrl+0：重置为100%缩放

🔄 旋转功能：
• ↺ 按钮：逆时针旋转90度
• ↻ 按钮：顺时针旋转90度
• 🔄 按钮：重置旋转到正常角度
• 注意：只有用户手动旋转才会改变显示，切换页面时保持旋转状态

🔢 数字键快捷键：
• Ctrl+1-9：快速跳转到对应页面

🖱️ 鼠标操作：
• 拖拽标题栏：移动预览器窗口
• 拖拽PDF区域：滚动PDF内容
• Ctrl+滚轮：以鼠标位置为中心缩放
• 双击PDF：智能缩放切换

📱 触摸操作（移动设备）：
• 双指缩放：缩放PDF
• 单指拖拽：滚动内容

💡 使用提示：
• 在输入框中时，大部分快捷键会被禁用
• 截图模式：拖拽选择区域，支持高分辨率截图
• 文本选择模式：可选择、复制和高亮文本
• 性能优化：大文件建议使用较低缩放比例
• 支持键盘导航，提高操作效率

🎯 当前状态：
• 缩放比例：${Math.round(currentScale * 100)}%
• 当前页面：${currentPage}/${totalPages}
• 用户旋转：${userRotation}度
• 文件大小：${currentPDFFile ? (currentPDFFile.size / 1024 / 1024).toFixed(1) + 'MB' : '未知'}
• 平均渲染时间：${PDFPerformanceMonitor.getAverageRenderTime().toFixed(0)}ms

🖥️ 硬件状态：
• GPU加速：${HardwareCapabilities.hasGPU ? '✅ 已启用' : '❌ 未检测到'}
• WebGL支持：${HardwareCapabilities.hasWebGL ? '✅ 支持' : '❌ 不支持'}
• 硬件加速：${HardwareCapabilities.hasHardwareAcceleration ? '✅ 支持' : '❌ 不支持'}
• 最大缩放：${HardwareCapabilities.getOptimalRenderSettings().maxScale}x
            `;

            alert(helpContent);
        }

        let pdfSelectionInitialized = false;

        function initPDFSelection() {

            if (pdfSelectionInitialized) {
                console.log('📷 PDF选择功能已初始化，跳过重复初始化');
                return;
            }

            console.log('📷 初始化PDF选择功能');
            pdfSelectionInitialized = true;

            let isMouseDown = false;
            let startX, startY;

            pdfCanvas.addEventListener('mousedown', (e) => {

                if (!isScreenshotMode) return;

                e.preventDefault();
                e.stopPropagation();

                isMouseDown = true;
                const canvasRect = pdfCanvas.getBoundingClientRect();
                const contentRect = document.getElementById('pdfCanvasContent').getBoundingClientRect();

                startX = e.clientX - canvasRect.left;
                startY = e.clientY - canvasRect.top;

                const overlayX = e.clientX - contentRect.left;
                const overlayY = e.clientY - contentRect.top;

                selectionStart = { x: startX, y: startY };
                selectionEnd = null;

                pdfSelectionOverlay.style.display = 'block';
                pdfSelectionOverlay.style.left = overlayX + 'px';
                pdfSelectionOverlay.style.top = overlayY + 'px';
                pdfSelectionOverlay.style.width = '0px';
                pdfSelectionOverlay.style.height = '0px';

                console.log('📷 开始截图选择:', {
                    canvasX: startX,
                    canvasY: startY,
                    overlayX: overlayX,
                    overlayY: overlayY,
                    canvasRect: {
                        left: canvasRect.left,
                        top: canvasRect.top,
                        width: canvasRect.width,
                        height: canvasRect.height
                    },
                    contentRect: {
                        left: contentRect.left,
                        top: contentRect.top,
                        width: contentRect.width,
                        height: contentRect.height
                    },
                    currentScale: currentScale
                });
            });

            pdfCanvas.addEventListener('mousemove', (e) => {
                if (!isMouseDown || !isScreenshotMode) return;

                e.preventDefault();

                const canvasRect = pdfCanvas.getBoundingClientRect();
                const contentRect = document.getElementById('pdfCanvasContent').getBoundingClientRect();

                const currentX = e.clientX - canvasRect.left;
                const currentY = e.clientY - canvasRect.top;

                const overlayCurrentX = e.clientX - contentRect.left;
                const overlayCurrentY = e.clientY - contentRect.top;
                const overlayStartX = selectionStart.x;
                const overlayStartY = selectionStart.y;

                const width = Math.abs(overlayCurrentX - overlayStartX);
                const height = Math.abs(overlayCurrentY - overlayStartY);
                const left = Math.min(overlayCurrentX, overlayStartX);
                const top = Math.min(overlayCurrentY, overlayStartY);

                pdfSelectionOverlay.style.left = left + 'px';
                pdfSelectionOverlay.style.top = top + 'px';
                pdfSelectionOverlay.style.width = width + 'px';
                pdfSelectionOverlay.style.height = height + 'px';

                selectionEnd = { x: currentX, y: currentY };

                selectionEnd = { x: currentX, y: currentY };
            });

            pdfCanvas.addEventListener('mouseup', (e) => {
                if (!isMouseDown || !isScreenshotMode) return;

                e.preventDefault();
                e.stopPropagation();

                isMouseDown = false;

                const canvasRect = pdfCanvas.getBoundingClientRect();
                const endX = e.clientX - canvasRect.left;
                const endY = e.clientY - canvasRect.top;

                selectionEnd = { x: endX, y: endY };

                const width = Math.abs(endX - startX);
                const height = Math.abs(endY - startY);

                console.log('📷 截图区域选择完成:', {
                    startX: startX,
                    startY: startY,
                    endX: endX,
                    endY: endY,
                    width: width,
                    height: height,
                    canvasSize: {
                        display: { width: canvasRect.width, height: canvasRect.height },
                        actual: { width: pdfCanvas.width, height: pdfCanvas.height }
                    }
                });

                if (width > 10 && height > 10) {

                    showPDFSelectionOptions();
                } else {
                    console.log('📷 截图区域太小，已清除');
                    clearPDFSelection();
                }
            });
        }

        let isShowingConfirm = false;

        function showPDFSelectionOptions() {

            if (isShowingConfirm) {
                console.log('📷 确认对话框已显示，跳过重复调用');
                return;
            }

            isShowingConfirm = true;
            console.log('📷 显示截图选项对话框');

            const now = new Date();
            const timestamp = now.getFullYear() +
                             String(now.getMonth() + 1).padStart(2, '0') +
                             String(now.getDate()).padStart(2, '0') + '_' +
                             String(now.getHours()).padStart(2, '0') +
                             String(now.getMinutes()).padStart(2, '0') +
                             String(now.getSeconds()).padStart(2, '0');

            const defaultFileName = `PDF截图_${currentPDFFileName.replace('.pdf', '')}_第${currentPage}页_${timestamp}`;
            document.getElementById('screenshotFileName').value = defaultFileName;

            document.getElementById('screenshotOptionsDialog').style.display = 'flex';
        }

        function closeScreenshotOptionsDialog(clearSelection = true) {
            document.getElementById('screenshotOptionsDialog').style.display = 'none';
            isShowingConfirm = false;
            if (clearSelection) {
                clearPDFSelection();
            }
        }

        async function confirmScreenshotOptions() {
            const uploadToChat = document.getElementById('uploadToChat').checked;
            const saveToLocal = document.getElementById('saveToLocal').checked;
            const fileName = document.getElementById('screenshotFileName').value.trim();

            if (!uploadToChat && !saveToLocal) {
                showStatus('请至少选择一种处理方式', 'error');
                return;
            }

            if (!fileName) {
                showStatus('请输入文件名', 'error');
                return;
            }

            console.log('📷 用户确认截图选项:', {
                uploadToChat: uploadToChat,
                saveToLocal: saveToLocal,
                fileName: fileName
            });

            document.getElementById('screenshotOptionsDialog').style.display = 'none';
            isShowingConfirm = false;

            if (window.currentWebPageScreenshotBlob) {

                try {
                    await processWebPageScreenshot(window.currentWebPageScreenshotBlob, uploadToChat, saveToLocal, fileName);

                    delete window.currentWebPageScreenshotBlob;
                } catch (error) {
                    console.error('📷 网页截图处理失败:', error);
                    showStatus('网页截图处理失败，请重试', 'error');
                }
            } else {

                try {
                    await capturePDFSelection(uploadToChat, saveToLocal, fileName);
                } catch (error) {
                    console.error('📷 PDF截图执行失败:', error);
                    showStatus('PDF截图失败，请重试', 'error');
                    clearPDFSelection();
                    isCapturingPDF = false;
                }
            }
        }

        async function processWebPageScreenshot(blob, uploadToChat, saveToLocal, fileName) {
            try {
                const finalFileName = fileName + '.png';
                const file = new File([blob], finalFileName, { type: 'image/png' });

                console.log('📷 处理网页截图:', {
                    fileName: finalFileName,
                    size: blob.size,
                    uploadToChat: uploadToChat,
                    saveToLocal: saveToLocal
                });

                if (saveToLocal) {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = finalFileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                    console.log('📷 网页截图已保存到本地:', finalFileName);
                }

                if (uploadToChat) {
                    console.log('📷 开始上传到聊天...');

                    console.log('📷 函数可用性检查:', {
                        uploadedFiles: typeof uploadedFiles !== 'undefined',
                        addFilePreview: typeof addFilePreview === 'function',
                        uploadFile: typeof uploadFile === 'function',
                        updateAttachmentIndicator: typeof updateAttachmentIndicator === 'function'
                    });

                    if (typeof uploadedFiles !== 'undefined') {
                        uploadedFiles.push(file);
                        console.log('📷 文件已添加到uploadedFiles，当前数量:', uploadedFiles.length);
                    } else {
                        console.error('📷 uploadedFiles未定义');
                    }

                    const fileId = 'webpage_screenshot_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    console.log('📷 生成文件ID:', fileId);

                    if (typeof addFilePreview === 'function') {
                        console.log('📷 调用addFilePreview...');
                        addFilePreview(file, fileId);
                        console.log('📷 addFilePreview调用完成');
                    } else {
                        console.error('📷 addFilePreview函数不存在');
                    }

                    if (typeof uploadFile === 'function') {
                        console.log('📷 调用uploadFile...');
                        uploadFile(file, fileId);
                        console.log('📷 uploadFile调用完成');
                    } else {
                        console.error('📷 uploadFile函数不存在');
                    }

                    if (typeof updateAttachmentIndicator === 'function') {
                        console.log('📷 调用updateAttachmentIndicator...');
                        updateAttachmentIndicator();
                        console.log('📷 updateAttachmentIndicator调用完成');
                    } else {
                        console.error('📷 updateAttachmentIndicator函数不存在');
                    }

                    console.log('📷 网页截图已添加到附件:', finalFileName);
                }

                let statusMessage = '网页截图处理完成';
                if (uploadToChat && saveToLocal) {
                    statusMessage = '网页截图已添加到附件并保存到本地';
                } else if (uploadToChat) {
                    statusMessage = '网页截图已添加到附件';
                } else if (saveToLocal) {
                    statusMessage = '网页截图已保存到本地';
                }

                showStatus(statusMessage, 'success');

            } catch (error) {
                console.error('📷 网页截图处理失败:', error);
                showStatus('网页截图处理失败: ' + error.message, 'error');
            }
        }

        let isCapturingPDF = false;

        async function capturePDFSelection(uploadToChat = true, saveToLocal = false, fileName = '') {
            console.log('📷 检查截图条件:', {
                pdfCanvas: !!pdfCanvas,
                selectionStart: selectionStart,
                selectionEnd: selectionEnd
            });

            if (!pdfCanvas || !selectionStart || !selectionEnd) {
                console.log('📷 截图条件不满足');
                return;
            }

            if (isCapturingPDF) {
                console.log('📷 正在处理截图，跳过重复调用');
                return;
            }

            isCapturingPDF = true;
            console.log('📷 开始处理PDF截图:', {
                uploadToChat: uploadToChat,
                saveToLocal: saveToLocal,
                fileName: fileName
            });

            const canvasRect = pdfCanvas.getBoundingClientRect();
            const canvasActualWidth = pdfCanvas.width;
            const canvasActualHeight = pdfCanvas.height;
            const canvasDisplayWidth = canvasRect.width;
            const canvasDisplayHeight = canvasRect.height;

            const scaleX = canvasActualWidth / canvasDisplayWidth;
            const scaleY = canvasActualHeight / canvasDisplayHeight;

            const left = Math.min(selectionStart.x, selectionEnd.x);
            const top = Math.min(selectionStart.y, selectionEnd.y);
            const width = Math.abs(selectionEnd.x - selectionStart.x);
            const height = Math.abs(selectionEnd.y - selectionStart.y);

            const actualLeft = left * scaleX;
            const actualTop = top * scaleY;
            const actualWidth = width * scaleX;
            const actualHeight = height * scaleY;

            const clampedLeft = Math.max(0, Math.min(actualLeft, canvasActualWidth - 1));
            const clampedTop = Math.max(0, Math.min(actualTop, canvasActualHeight - 1));
            const clampedRight = Math.max(clampedLeft + 1, Math.min(actualLeft + actualWidth, canvasActualWidth));
            const clampedBottom = Math.max(clampedTop + 1, Math.min(actualTop + actualHeight, canvasActualHeight));
            const clampedWidth = clampedRight - clampedLeft;
            const clampedHeight = clampedBottom - clampedTop;

            console.log('📷 坐标计算详情:', {
                original: { left: actualLeft, top: actualTop, width: actualWidth, height: actualHeight },
                clamped: { left: clampedLeft, top: clampedTop, width: clampedWidth, height: clampedHeight },
                canvas: { width: canvasActualWidth, height: canvasActualHeight }
            });

            if (clampedWidth <= 0 || clampedHeight <= 0) {
                console.log('📷 截图区域计算后无效:', { clampedWidth, clampedHeight });
                showStatus('选择区域无效，请重新选择', 'error');
                clearPDFSelection();
                isCapturingPDF = false;
                return;
            }

            await captureHighResolutionPDFArea(clampedLeft, clampedTop, clampedWidth, clampedHeight, uploadToChat, saveToLocal, fileName);
        }

        async function captureHighResolutionPDFArea(left, top, width, height, uploadToChat, saveToLocal, fileName) {
            try {
                console.log('📷 开始高分辨率截图渲染:', { left, top, width, height });

                const highResScale = currentScale * 3.0;
                const page = await currentPDF.getPage(currentPage);
                const viewport = page.getViewport({ scale: highResScale });

                const highResCanvas = document.createElement('canvas');
                const highResContext = highResCanvas.getContext('2d');

                highResCanvas.width = viewport.width;
                highResCanvas.height = viewport.height;

                const renderContext = {
                    canvasContext: highResContext,
                    viewport: viewport
                };

                await page.render(renderContext).promise;

                const scaleRatio = highResScale / currentScale;
                const highResLeft = left * scaleRatio;
                const highResTop = top * scaleRatio;
                const highResWidth = width * scaleRatio;
                const highResHeight = height * scaleRatio;

                const clampedLeft = Math.max(0, Math.min(highResLeft, viewport.width - 1));
                const clampedTop = Math.max(0, Math.min(highResTop, viewport.height - 1));
                const clampedRight = Math.max(clampedLeft + 1, Math.min(highResLeft + highResWidth, viewport.width));
                const clampedBottom = Math.max(clampedTop + 1, Math.min(highResTop + highResHeight, viewport.height));
                const clampedWidth = clampedRight - clampedLeft;
                const clampedHeight = clampedBottom - clampedTop;

                console.log('📷 高分辨率坐标计算:', {
                    original: { left: highResLeft, top: highResTop, width: highResWidth, height: highResHeight },
                    clamped: { left: clampedLeft, top: clampedTop, width: clampedWidth, height: clampedHeight },
                    viewport: { width: viewport.width, height: viewport.height },
                    scaleRatio: scaleRatio
                });

                const finalCanvas = document.createElement('canvas');
                const finalContext = finalCanvas.getContext('2d');

                finalCanvas.width = clampedWidth;
                finalCanvas.height = clampedHeight;

                finalContext.drawImage(
                    highResCanvas,
                    clampedLeft, clampedTop, clampedWidth, clampedHeight,
                    0, 0, clampedWidth, clampedHeight
                );

                finalCanvas.toBlob((blob) => {
                    const finalFileName = fileName ? fileName + '.png' : 'PDF截图_页面' + currentPage + '_' + Date.now() + '.png';
                    const file = new File([blob], finalFileName, { type: 'image/png' });

                    console.log('📷 高分辨率截图生成完成:', {
                        fileName: finalFileName,
                        size: blob.size,
                        dimensions: { width: clampedWidth, height: clampedHeight }
                    });

                    if (saveToLocal) {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = finalFileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                        console.log('📷 高分辨率截图已保存到本地:', finalFileName);
                    }

                    if (uploadToChat) {

                        uploadedFiles.push(file);

                        const fileId = 'screenshot_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                        addFilePreview(file, fileId);

                        uploadFile(file, fileId);

                        updateAttachmentIndicator();

                        console.log('📷 高分辨率截图已添加到附件:', finalFileName);
                    }

                    let statusMessage = '高分辨率截图处理完成';
                    if (uploadToChat && saveToLocal) {
                        statusMessage = '高分辨率PDF截图已添加到附件并保存到本地';
                    } else if (uploadToChat) {
                        statusMessage = '高分辨率PDF截图已添加到附件';
                    } else if (saveToLocal) {
                        statusMessage = '高分辨率PDF截图已保存到本地';
                    }

                    showStatus(statusMessage, 'success');
                    clearPDFSelection();

                    isCapturingPDF = false;
                    console.log('📷 高分辨率PDF截图处理完成');
                }, 'image/png', 0.95);

            } catch (error) {
                console.error('📷 高分辨率截图失败:', error);
                showStatus('高分辨率截图失败，请重试', 'error');
                clearPDFSelection();
                isCapturingPDF = false;
            }
        }

        function clearPDFSelection() {
            pdfSelectionOverlay.style.display = 'none';
            selectionStart = null;
            selectionEnd = null;
        }

        function addPDFAnnotation(text, page, position) {
            const annotation = {
                id: Date.now(),
                text: text,
                page: page,
                position: position,
                timestamp: new Date().toLocaleString()
            };

            pdfAnnotations.push(annotation);
            updatePDFAnnotationsList();
        }

        function addPDFBookmark(title, page) {
            const bookmark = {
                id: Date.now(),
                title: title || ('页面 ' + page),
                page: page,
                timestamp: new Date().toLocaleString()
            };

            pdfBookmarks.push(bookmark);
            updatePDFBookmarksList();
        }

        function updatePDFBookmarksList() {

            setupPagination('bookmarks', pdfBookmarks, renderBookmarksPage);

            setTimeout(refreshScrolling, 100);
        }

        async function extractFullPDFText() {
            if (!currentPDF) return '';

            let fullText = '';
            try {
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    const page = await currentPDF.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    let pageText = '';
                    textContent.items.forEach(item => {
                        pageText += item.str + ' ';
                    });

                    fullText += '\n\n=== 第' + pageNum + '页 ===\n' + pageText;
                }
                return fullText.trim();
            } catch (error) {
                console.error('PDF文本提取失败:', error);
                return '';
            }
        }

        async function performPDFSearch(query) {

            if (typeof query !== 'string') {
                console.error('performPDFSearch: query must be a string, got:', typeof query, query);
                showStatus('搜索参数错误', 'error');
                return;
            }

            if (!currentPDF || !query.trim()) {
                showStatus('请输入搜索关键词', 'warning');
                return;
            }

            showStatus('正在搜索: "' + query + '"...', 'info');

            const pdfSidebar = document.getElementById('pdfSidebar');

            if (pdfSidebar) {
                pdfSidebar.style.display = 'block';
            }

            switchSidebarTab('search');

            pdfSearchResultsData = [];

            try {
                let totalMatches = 0;

                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    const page = await currentPDF.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    let pageText = '';
                    textContent.items.forEach(item => {
                        pageText += item.str + ' ';
                    });

                    const regex = new RegExp(query, 'gi');
                    let match;
                    while ((match = regex.exec(pageText)) !== null) {
                        const start = Math.max(0, match.index - 50);
                        const end = Math.min(pageText.length, match.index + match[0].length + 50);
                        const context = pageText.substring(start, end);

                        pdfSearchResultsData.push({
                            page: pageNum,
                            text: match[0],
                            context: context,
                            index: match.index
                        });
                        totalMatches++;
                    }
                }

                updateSidebarSearchResults(pdfSearchResultsData, query);

                if (totalMatches > 0) {
                    showStatus('找到 ' + totalMatches + ' 个匹配结果', 'success');

                    if (pdfSearchResultsData.length > 0) {
                        renderPDFPage(pdfSearchResultsData[0].page);
                    }
                } else {
                    showStatus('未找到 "' + query + '"', 'warning');
                }

            } catch (error) {
                console.error('PDF搜索失败:', error);
                showStatus('PDF搜索失败', 'error');
            }
        }

        function updateSidebarSearchResults(results, searchTerm) {
            console.log('开始更新搜索结果:', results.length, '个结果');

            paginationStates.search.searchTerm = searchTerm;

            setupPagination('search', results, renderSearchPage);

            fixSidebarLayout();

            setTimeout(() => {
                refreshScrolling();

                setTimeout(refreshScrolling, 200);
            }, 200);
        }

        function fixSidebarLayout() {
            console.log('修复侧边栏布局...');

            const sidebar = document.getElementById('pdfSidebar');
            if (sidebar) {
                sidebar.style.display = 'flex';
                sidebar.style.flexDirection = 'column';
                sidebar.style.height = '100%';
                sidebar.style.overflow = 'hidden';
            }

            const tabContent = sidebar?.querySelector('.pdf-tab-content');
            if (tabContent) {
                tabContent.style.display = 'flex';
                tabContent.style.flexDirection = 'column';
                tabContent.style.flex = '1';
                tabContent.style.overflow = 'hidden';
                tabContent.style.minHeight = '0';
            }

            document.querySelectorAll('.pdf-tab-panel').forEach(panel => {
                panel.style.flexDirection = 'column';
                panel.style.minHeight = '0';
                panel.style.overflow = 'hidden';

                if (panel.classList.contains('active')) {
                    panel.style.display = 'flex !important';
                    panel.style.flex = '1';
                } else {
                    panel.style.display = 'none !important';
                }
            });

            ['pdfOutlineList', 'pdfAnnotationsList', 'pdfBookmarksList', 'pdfSearchResultsList'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.flex = '1';
                    element.style.overflowY = 'auto';
                    element.style.minHeight = '0';
                    element.style.maxHeight = 'none';
                }
            });

            console.log('侧边栏布局修复完成');
        }

        function displaySearchResultsPage(results, searchTerm, page) {
            const pdfSearchResultsList = document.getElementById('pdfSearchResultsList');
            if (!pdfSearchResultsList) return;

            const startIndex = (page - 1) * searchItemsPerPage;
            const endIndex = Math.min(startIndex + searchItemsPerPage, results.length);
            const pageResults = results.slice(startIndex, endIndex);

            let html = `<div style="margin-bottom: 10px; font-weight: bold; color: #007bff;">
                找到 ${results.length} 个结果 (第 ${page}/${searchTotalPages} 页):
            </div>`;

            pageResults.forEach((result, index) => {
                const highlightedContext = result.context.replace(
                    new RegExp(searchTerm, 'gi'),
                    '<mark style="background: #ffeb3b; padding: 1px 2px;">$&</mark>'
                );

                const globalIndex = startIndex + index + 1;
                html += `
                    <div class="pdf-search-result" onclick="renderPDFPage(${result.page})"
                         style="padding: 10px; margin: 8px 0; background: #fff; border: 1px solid #dee2e6;
                                border-radius: 6px; cursor: pointer; font-size: 13px; transition: all 0.2s;
                                box-shadow: 0 1px 3px rgba(0,0,0,0.1);"
                         onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)'; this.style.borderColor='#007bff';"
                         onmouseout="this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)'; this.style.borderColor='#dee2e6';">
                        <div style="color: #007bff; font-weight: bold; margin-bottom: 5px;">📄 结果 ${globalIndex} - 第 ${result.page} 页</div>
                        <div style="line-height: 1.4; color: #333;">${highlightedContext}</div>
                    </div>
                `;
            });

            pdfSearchResultsList.innerHTML = html;
        }

        function updateSearchPagination(results, searchTerm) {
            const paginationInfo = document.getElementById('paginationInfo');
            const paginationControls = document.getElementById('paginationControls');

            if (!paginationInfo || !paginationControls) return;

            paginationInfo.innerHTML = `共 ${results.length} 个结果，${searchTotalPages} 页`;

            let controlsHtml = '';

            if (searchCurrentPage > 1) {
                controlsHtml += `<button class="pagination-btn" onclick="goToSearchPage(${searchCurrentPage - 1})">‹</button>`;
            }

            const maxVisiblePages = 5;
            let startPage = Math.max(1, searchCurrentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(searchTotalPages, startPage + maxVisiblePages - 1);

            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === searchCurrentPage;
                const isVisited = visitedSearchPages.has(i);
                const classes = ['pagination-btn'];

                if (isActive) classes.push('active');
                else if (isVisited) classes.push('visited');

                controlsHtml += `<button class="${classes.join(' ')}" onclick="goToSearchPage(${i})">${i}</button>`;
            }

            if (searchCurrentPage < searchTotalPages) {
                controlsHtml += `<button class="pagination-btn" onclick="goToSearchPage(${searchCurrentPage + 1})">›</button>`;
            }

            paginationControls.innerHTML = controlsHtml;
        }

        function goToSearchPage(page) {
            if (page < 1 || page > searchTotalPages) return;

            searchCurrentPage = page;
            visitedSearchPages.add(page);

            displaySearchResultsPage(pdfSearchResultsData, currentSearchTerm, page);
            updateSearchPagination(pdfSearchResultsData, currentSearchTerm);
        }

        function setupPagination(tabName, data, renderFunction) {
            const state = paginationStates[tabName];
            if (!state) return;

            state.data = data;
            state.currentPage = 1;
            state.totalPages = Math.ceil(data.length / itemsPerPage);
            state.visitedPages.clear();
            state.visitedPages.add(1);

            displayPageData(tabName, renderFunction);

            if (state.totalPages > 1) {
                updatePaginationControls(tabName);
                showPagination(tabName, true);
            } else {
                showPagination(tabName, false);
            }
        }

        function displayPageData(tabName, renderFunction) {
            const state = paginationStates[tabName];
            if (!state) return;

            const startIndex = (state.currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, state.data.length);
            const pageData = state.data.slice(startIndex, endIndex);

            renderFunction(pageData, state.currentPage, state.totalPages, state.data.length);
        }

        function updatePaginationControls(tabName) {
            const state = paginationStates[tabName];
            const infoElement = document.getElementById(tabName + 'PaginationInfo');
            const controlsElement = document.getElementById(tabName + 'PaginationControls');

            if (!state || !infoElement || !controlsElement) return;

            infoElement.innerHTML = `共 ${state.data.length} 项，第 ${state.currentPage}/${state.totalPages} 页`;

            let controlsHtml = '';

            if (state.currentPage > 1) {
                controlsHtml += `<button class="pagination-btn" onclick="goToPage('${tabName}', ${state.currentPage - 1})">‹</button>`;
            }

            const maxVisiblePages = 5;
            let startPage = Math.max(1, state.currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(state.totalPages, startPage + maxVisiblePages - 1);

            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === state.currentPage;
                const isVisited = state.visitedPages.has(i);
                const classes = ['pagination-btn'];

                if (isActive) classes.push('active');
                else if (isVisited) classes.push('visited');

                controlsHtml += `<button class="${classes.join(' ')}" onclick="goToPage('${tabName}', ${i})">${i}</button>`;
            }

            if (state.currentPage < state.totalPages) {
                controlsHtml += `<button class="pagination-btn" onclick="goToPage('${tabName}', ${state.currentPage + 1})">›</button>`;
            }

            controlsElement.innerHTML = controlsHtml;
        }

        function goToPage(tabName, page) {
            const state = paginationStates[tabName];
            if (!state || page < 1 || page > state.totalPages) return;

            state.currentPage = page;
            state.visitedPages.add(page);

            switch(tabName) {
                case 'outline':
                    displayPageData(tabName, renderOutlinePage);
                    break;
                case 'annotations':
                    displayPageData(tabName, renderAnnotationsPage);
                    break;
                case 'bookmarks':
                    displayPageData(tabName, renderBookmarksPage);
                    break;
                case 'search':
                    displayPageData(tabName, renderSearchPage);
                    break;
            }

            updatePaginationControls(tabName);
        }

        function showPagination(tabName, show) {
            const paginationElement = document.getElementById(tabName + 'Pagination');
            if (paginationElement) {
                paginationElement.style.display = show ? 'block' : 'none';
            }
        }

        function refreshScrolling() {
            console.log('开始刷新滚动功能...');

            const scrollableElements = [
                'pdfOutlineList',
                'pdfAnnotationsList',
                'pdfBookmarksList',
                'pdfSearchResultsList'
            ];

            scrollableElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {

                    const scrollTop = element.scrollTop;

                    element.style.overflow = '';
                    element.style.overflowY = 'auto !important';
                    element.style.minHeight = '0 !important';
                    element.style.flex = '1 !important';
                    element.style.maxHeight = 'none !important';

                    const parent = element.parentElement;
                    if (parent && parent.classList.contains('pdf-tab-panel')) {
                        parent.style.display = 'flex';
                        parent.style.flexDirection = 'column';
                        parent.style.minHeight = '0';
                        parent.style.overflow = 'hidden';
                    }

                    element.offsetHeight;

                    element.scrollTop = scrollTop;

                    console.log(`刷新滚动: ${id}`, {
                        scrollHeight: element.scrollHeight,
                        clientHeight: element.clientHeight,
                        overflowY: getComputedStyle(element).overflowY,
                        parentDisplay: parent ? getComputedStyle(parent).display : 'none',
                        parentFlexDirection: parent ? getComputedStyle(parent).flexDirection : 'none'
                    });
                } else {
                    console.warn(`元素 ${id} 未找到`);
                }
            });

            console.log('滚动功能刷新完成');
        }

        function renderOutlinePage(pageData, currentPage, totalPages, totalItems) {
            const outlineList = document.getElementById('pdfOutlineList');
            if (!outlineList) return;

            if (pageData.length === 0) {
                outlineList.innerHTML = '暂无目录';
                return;
            }

            outlineList.innerHTML = '';

            pageData.forEach((item, index) => {
                const globalIndex = (currentPage - 1) * itemsPerPage + index + 1;
                const itemId = `outline-${globalIndex}`;

                const itemDiv = document.createElement('div');
                itemDiv.className = 'pdf-outline-item';
                itemDiv.id = itemId;
                itemDiv.style.cssText = `padding: 8px; margin: 4px 0; cursor: pointer; border-radius: 4px; transition: all 0.3s; padding-left: ${item.level * 10}px;`;

                const isVisited = visitedItems.outline.has(itemId);
                const isCurrent = currentViewingPage === item.page;

                if (isCurrent) {
                    itemDiv.classList.add('current');
                } else if (isVisited) {
                    itemDiv.classList.add('visited');
                }

                itemDiv.addEventListener('click', () => {

                    visitedItems.outline.add(itemId);

                    document.querySelectorAll('.pdf-outline-item.current').forEach(el => {
                        el.classList.remove('current');
                        el.classList.add('visited');
                    });

                    itemDiv.classList.remove('visited');
                    itemDiv.classList.add('current');

                    navigateToOutlineItem(JSON.stringify(item.dest), item.page);
                });

                itemDiv.addEventListener('mouseover', () => {
                    if (!itemDiv.classList.contains('current') && !itemDiv.classList.contains('visited')) {
                        itemDiv.style.background = '#f8f9fa';
                    }
                });

                itemDiv.addEventListener('mouseout', () => {
                    if (!itemDiv.classList.contains('current') && !itemDiv.classList.contains('visited')) {
                        itemDiv.style.background = 'transparent';
                    }
                });

                itemDiv.innerHTML = `
                    <div class="item-title" style="font-weight: bold; color: #007bff;">${item.title}</div>
                    <div style="font-size: 12px; color: #666;">第 ${item.page} 页</div>
                `;

                outlineList.appendChild(itemDiv);
            });
        }

        function renderAnnotationsPage(pageData, currentPage, totalPages, totalItems) {
            const annotationsList = document.getElementById('pdfAnnotationsList');
            if (!annotationsList) return;

            if (pageData.length === 0) {
                annotationsList.innerHTML = '暂无注释';
                return;
            }

            annotationsList.innerHTML = '';

            pageData.forEach((annotation, index) => {
                const globalIndex = (currentPage - 1) * itemsPerPage + index + 1;
                const itemId = `annotation-${annotation.id || globalIndex}`;

                const itemDiv = document.createElement('div');
                itemDiv.className = 'pdf-annotation-item';
                itemDiv.id = itemId;
                itemDiv.style.cssText = 'background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin-bottom: 10px; cursor: pointer; transition: all 0.3s;';

                const isVisited = visitedItems.annotations.has(itemId);
                const isCurrent = currentViewingPage === annotation.page;

                if (isCurrent) {
                    itemDiv.classList.add('current');
                } else if (isVisited) {
                    itemDiv.classList.add('visited');
                }

                itemDiv.addEventListener('click', () => {

                    visitedItems.annotations.add(itemId);

                    document.querySelectorAll('.pdf-annotation-item.current').forEach(el => {
                        el.classList.remove('current');
                        el.classList.add('visited');
                    });

                    itemDiv.classList.remove('visited');
                    itemDiv.classList.add('current');

                    renderPDFPage(annotation.page);
                });

                itemDiv.innerHTML = `
                    <div class="item-title" style="font-weight: bold; color: #007bff; margin-bottom: 5px;">${globalIndex}. ${annotation.type === 'highlight' ? '🖍️ 高亮' : '📝 注释'}</div>
                    <div style="font-size: 13px; margin-bottom: 5px;">"${annotation.text}"</div>
                    <div style="font-size: 12px; color: #666;">第 ${annotation.page} 页 - ${annotation.timestamp}</div>
                `;

                annotationsList.appendChild(itemDiv);
            });
        }

        function renderBookmarksPage(pageData, currentPage, totalPages, totalItems) {
            const bookmarksList = document.getElementById('pdfBookmarksList');
            if (!bookmarksList) return;

            if (pageData.length === 0) {
                bookmarksList.innerHTML = '暂无书签';
                return;
            }

            bookmarksList.innerHTML = '';

            pageData.forEach((bookmark, index) => {
                const globalIndex = (currentPage - 1) * itemsPerPage + index + 1;
                const itemId = `bookmark-${bookmark.id || globalIndex}`;

                const itemDiv = document.createElement('div');
                itemDiv.className = 'pdf-annotation-item';
                itemDiv.id = itemId;
                itemDiv.style.cssText = 'background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin-bottom: 10px; cursor: pointer; transition: all 0.3s;';

                const isVisited = visitedItems.bookmarks.has(itemId);
                const isCurrent = currentViewingPage === bookmark.page;

                if (isCurrent) {
                    itemDiv.classList.add('current');
                } else if (isVisited) {
                    itemDiv.classList.add('visited');
                }

                itemDiv.addEventListener('click', () => {

                    visitedItems.bookmarks.add(itemId);

                    document.querySelectorAll('.pdf-annotation-item.current').forEach(el => {
                        el.classList.remove('current');
                        el.classList.add('visited');
                    });

                    itemDiv.classList.remove('visited');
                    itemDiv.classList.add('current');

                    renderPDFPage(bookmark.page);
                });

                itemDiv.innerHTML = `
                    <div class="item-title" style="font-weight: bold; color: #007bff; margin-bottom: 5px;">${globalIndex}. 🔖 ${bookmark.title}</div>
                    <div style="font-size: 12px; color: #666;">第 ${bookmark.page} 页 - ${bookmark.timestamp}</div>
                `;

                bookmarksList.appendChild(itemDiv);
            });
        }

        function renderSearchPage(pageData, currentPage, totalPages, totalItems) {
            const searchResultsList = document.getElementById('pdfSearchResultsList');
            if (!searchResultsList) {
                console.error('pdfSearchResultsList element not found!');
                return;
            }

            console.log('渲染搜索页面:', {
                pageData: pageData.length,
                currentPage,
                totalPages,
                totalItems,
                elementId: searchResultsList.id,
                elementParent: searchResultsList.parentElement?.id
            });

            const searchTerm = paginationStates.search.searchTerm;

            if (pageData.length === 0) {
                searchResultsList.innerHTML = searchTerm ? `未找到"${searchTerm}"` : '输入关键词开始搜索';
                return;
            }

            searchResultsList.innerHTML = '';

            searchResultsList.style.overflowY = 'auto';
            searchResultsList.style.flex = '1';
            searchResultsList.style.minHeight = '0';

            pageData.forEach((result, index) => {
                const globalIndex = (currentPage - 1) * itemsPerPage + index + 1;
                const itemId = `search-${globalIndex}-${result.page}`;
                const highlightedContext = result.context.replace(
                    new RegExp(searchTerm, 'gi'),
                    '<mark style="background: #ffeb3b; padding: 1px 2px;">$&</mark>'
                );

                const itemDiv = document.createElement('div');
                itemDiv.className = 'pdf-search-result';
                itemDiv.id = itemId;
                itemDiv.style.cssText = `padding: 10px; margin: 8px 0; background: #fff; border: 1px solid #dee2e6;
                                        border-radius: 6px; cursor: pointer; font-size: 13px; transition: all 0.3s;
                                        box-shadow: 0 1px 3px rgba(0,0,0,0.1);`;

                const isVisited = visitedItems.search.has(itemId);
                const isCurrent = currentViewingPage === result.page;

                if (isCurrent) {
                    itemDiv.classList.add('current');
                } else if (isVisited) {
                    itemDiv.classList.add('visited');
                }

                itemDiv.addEventListener('click', () => {

                    visitedItems.search.add(itemId);

                    document.querySelectorAll('.pdf-search-result.current').forEach(el => {
                        el.classList.remove('current');
                        el.classList.add('visited');
                    });

                    itemDiv.classList.remove('visited');
                    itemDiv.classList.add('current');

                    renderPDFPage(result.page);
                });

                itemDiv.addEventListener('mouseover', () => {
                    if (!itemDiv.classList.contains('current') && !itemDiv.classList.contains('visited')) {
                        itemDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                        itemDiv.style.borderColor = '#007bff';
                    }
                });

                itemDiv.addEventListener('mouseout', () => {
                    if (!itemDiv.classList.contains('current') && !itemDiv.classList.contains('visited')) {
                        itemDiv.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
                        itemDiv.style.borderColor = '#dee2e6';
                    }
                });

                itemDiv.innerHTML = `
                    <div class="item-title" style="color: #007bff; font-weight: bold; margin-bottom: 5px;">📄 结果 ${globalIndex} - 第 ${result.page} 页</div>
                    <div style="line-height: 1.4; color: #333;">${highlightedContext}</div>
                `;

                searchResultsList.appendChild(itemDiv);
            });

            searchResultsList.offsetHeight;

            console.log('搜索结果渲染完成:', {
                scrollHeight: searchResultsList.scrollHeight,
                clientHeight: searchResultsList.clientHeight,
                overflowY: getComputedStyle(searchResultsList).overflowY
            });
        }

        function testSidebarScrolling() {
            console.log('测试侧边栏滚动功能...');

            const testAnnotations = [];
            for (let i = 1; i <= 25; i++) {
                testAnnotations.push({
                    id: i,
                    type: 'note',
                    text: `测试注释 ${i} - 这是一个用于测试滚动功能的长注释内容`,
                    page: i,
                    timestamp: new Date().toLocaleString()
                });
            }

            const testBookmarks = [];
            for (let i = 1; i <= 20; i++) {
                testBookmarks.push({
                    title: `测试书签 ${i}`,
                    page: i,
                    timestamp: new Date().toLocaleString()
                });
            }

            pdfAnnotations.push(...testAnnotations);
            pdfBookmarks.push(...testBookmarks);

            updatePDFAnnotationsList();
            updatePDFBookmarksList();

            console.log('测试数据已添加，请检查侧边栏滚动功能');
        }

        function emergencyFixTabs() {
            console.log('紧急修复标签页...');

            document.querySelectorAll('.pdf-tab-panel').forEach(panel => {
                panel.style.display = 'none';
            });

            const activePanel = document.querySelector('.pdf-tab-panel.active');
            if (activePanel) {
                activePanel.style.display = 'flex';
                activePanel.style.flexDirection = 'column';
                activePanel.style.flex = '1';
                activePanel.style.minHeight = '0';
            }

            if (!activePanel) {
                const outlinePanel = document.getElementById('pdfOutlinePanel');
                if (outlinePanel) {

                    document.querySelectorAll('.pdf-tab-panel').forEach(p => p.classList.remove('active'));
                    document.querySelectorAll('.pdf-tab-btn').forEach(b => b.classList.remove('active'));

                    outlinePanel.classList.add('active');
                    outlinePanel.style.display = 'flex';

                    const outlineBtn = document.querySelector('[data-tab="outline"]');
                    if (outlineBtn) outlineBtn.classList.add('active');
                }
            }

            console.log('标签页修复完成');
        }

        function clearVisitedItems(tabName = null) {
            if (tabName) {
                visitedItems[tabName].clear();
                console.log(`已清除 ${tabName} 标签页的访问状态`);
            } else {
                Object.keys(visitedItems).forEach(key => {
                    visitedItems[key].clear();
                });
                console.log('已清除所有标签页的访问状态');
            }

            document.querySelectorAll('.visited, .current').forEach(el => {
                el.classList.remove('visited', 'current');
            });
        }

        window.testSidebarScrolling = testSidebarScrolling;
        window.refreshScrolling = refreshScrolling;
        window.fixSidebarLayout = fixSidebarLayout;
        window.emergencyFixTabs = emergencyFixTabs;
        window.clearVisitedItems = clearVisitedItems;
        window.scrollLiteraturePanel = scrollLiteraturePanel;
        window.scrollLiteraturePanelToTop = scrollLiteraturePanelToTop;
        window.scrollLiteraturePanelToBottom = scrollLiteraturePanelToBottom;

        window.openLiteratureSidebar = function() {
            const sidebar = document.getElementById('literatureSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const btnText = document.getElementById('sidebarBtnText');
            const openBtn = document.getElementById('sidebarOpenBtn');

            if (sidebar && overlay) {
                sidebar.classList.add('open');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                if (btnText) btnText.textContent = '关闭助手';
                if (openBtn) {
                    openBtn.title = '关闭文献阅读助手';
                    openBtn.style.background = '#28a745';
                }
            }
        };

        window.closeLiteratureSidebar = function() {
            const sidebar = document.getElementById('literatureSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const btnText = document.getElementById('sidebarBtnText');
            const openBtn = document.getElementById('sidebarOpenBtn');

            if (sidebar && overlay) {
                sidebar.classList.remove('open');
                overlay.classList.remove('active');
                document.body.style.overflow = '';

                if (btnText) btnText.textContent = '文献助手';
                if (openBtn) {
                    openBtn.title = '打开文献阅读助手';
                    openBtn.style.background = '';
                }
            }
        };

        window.setSidebarWidth = function(width) {
            const sidebar = document.getElementById('literatureSidebar');
            if (sidebar) {
                sidebar.style.width = width + 'px';
                sidebar.style.left = sidebar.classList.contains('open') ? '0' : `-${width}px`;
                console.log(`侧边栏宽度已调整为 ${width}px`);
            }
        };

        window.testPDFDrag = function() {
            const container = document.getElementById('pdfViewerContainer');
            if (container) {
                const rect = container.getBoundingClientRect();
                console.log('PDF预览框位置信息:', {
                    left: container.style.left,
                    top: container.style.top,
                    offsetLeft: container.offsetLeft,
                    offsetTop: container.offsetTop,
                    boundingRect: {
                        left: rect.left,
                        top: rect.top,
                        width: rect.width,
                        height: rect.height
                    }
                });
            }
        };

        window.maximizePDFViewer = function() {
            const container = document.getElementById('pdfViewerContainer');
            if (container) {
                container.style.width = '95vw';
                container.style.height = '90vh';
                container.style.left = '2.5vw';
                container.style.top = '5vh';
                console.log('PDF预览框已最大化');
            }
        };

        window.resetPDFViewerSize = function() {
            const container = document.getElementById('pdfViewerContainer');
            if (container) {
                container.style.width = '60vw';
                container.style.height = '80vh';
                container.style.left = 'calc(100vw - 60vw - 20px)';
                container.style.top = '50px';
                console.log('PDF预览框已重置为默认大小');
            }
        };

        window.centerPDFViewer = function() {
            const container = document.getElementById('pdfViewerContainer');
            if (container) {
                const width = container.offsetWidth;
                const height = container.offsetHeight;
                container.style.left = `calc(50vw - ${width/2}px)`;
                container.style.top = `calc(50vh - ${height/2}px)`;
                console.log('PDF预览框已居中');
            }
        };

        window.testUrlInput = function() {
            const urlInput = document.getElementById('pdfUrlInput');
            const loadBtn = document.getElementById('pdfLoadUrl');

            console.log('URL输入框测试:', {
                urlInput: urlInput,
                loadBtn: loadBtn,
                urlInputValue: urlInput ? urlInput.value : 'null',
                urlInputDisabled: urlInput ? urlInput.disabled : 'null',
                urlInputStyle: urlInput ? urlInput.style.cssText : 'null'
            });

            if (urlInput) {
                urlInput.focus();
                console.log('已聚焦URL输入框');
            }
        };

        window.testWebPageScreenshot = function() {
            const webContainer = document.getElementById('webPageContainer');
            const iframe = document.getElementById('webPageIframe');
            const screenshotBtn = document.getElementById('webPageScreenshot');

            console.log('网页截图测试:', {
                webContainer: !!webContainer,
                iframe: !!iframe,
                screenshotBtn: !!screenshotBtn,
                containerSize: webContainer ? {
                    width: webContainer.offsetWidth,
                    height: webContainer.offsetHeight,
                    rect: webContainer.getBoundingClientRect()
                } : null,
                iframeSize: iframe ? {
                    width: iframe.offsetWidth,
                    height: iframe.offsetHeight
                } : null,
                windowSize: {
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight
                }
            });

            if (screenshotBtn) {
                console.log('模拟点击截图按钮');
                screenshotBtn.click();
            }
        };

        window.testCoordinateCalculation = function(left = 100, top = 100, width = 200, height = 150) {
            const webContainer = document.getElementById('webPageContainer');
            if (!webContainer) {
                console.error('找不到网页容器');
                return;
            }

            const containerRect = webContainer.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const browserUIHeight = window.outerHeight - window.innerHeight;

            const videoWidth = window.screen.width;
            const videoHeight = window.screen.height;

            const containerInWindowLeft = containerRect.left;
            const containerInWindowTop = containerRect.top;
            const selectionInWindowLeft = containerInWindowLeft + left;
            const selectionInWindowTop = containerInWindowTop + top;

            const scaleX = videoWidth / windowWidth;
            const scaleY = videoHeight / (windowHeight + browserUIHeight);

            const actualLeft = Math.round(selectionInWindowLeft * scaleX);
            const actualTop = Math.round((selectionInWindowTop + browserUIHeight) * scaleY);
            const actualWidth = Math.round(width * scaleX);
            const actualHeight = Math.round(height * scaleY);

            console.log('📷 坐标计算测试:', {
                输入: { left, top, width, height },
                容器位置: { left: containerRect.left, top: containerRect.top },
                窗口尺寸: { windowWidth, windowHeight },
                浏览器UI高度: browserUIHeight,
                视频尺寸: { videoWidth, videoHeight },
                缩放比例: { scaleX, scaleY },
                选择区域在窗口中的位置: { selectionInWindowLeft, selectionInWindowTop },
                最终截图区域: { actualLeft, actualTop, actualWidth, actualHeight }
            });
        };

        window.calibrateBrowserUI = function(actualUIHeight) {
            if (typeof actualUIHeight === 'number' && actualUIHeight > 0) {
                window.customBrowserUIHeight = actualUIHeight;
                console.log('📷 已设置自定义UI高度:', actualUIHeight);
                console.log('📷 使用方法: 如果截图上下位置仍有偏差，可以调用 calibrateBrowserUI(实际高度) 来校准');
            } else {
                console.log('📷 当前浏览器UI信息:', {
                    outerHeight: window.outerHeight,
                    innerHeight: window.innerHeight,
                    计算的UI高度: window.outerHeight - window.innerHeight,
                    自定义UI高度: window.customBrowserUIHeight || '未设置'
                });
                console.log('📷 校准方法: calibrateBrowserUI(实际UI高度)');
                console.log('📷 例如: calibrateBrowserUI(90) // 如果你的浏览器UI高度是90像素');
            }
        };

        window.stopLiteratureScrolling = function() {
            const panelContent = document.getElementById('literaturePanelContent');
            if (panelContent) {

                panelContent.removeEventListener('scroll', throttledUpdate);
                panelContent.removeEventListener('keydown', () => {});

                const scrollIndicator = document.getElementById('literatureScrollIndicator');
                if (scrollIndicator) {
                    scrollIndicator.classList.remove('show');
                }

                panelContent.classList.remove('has-scroll');
                console.log('文献助手滚动监听器已停止');
            }
        };

        function initLiteraturePanelScrolling() {
            const panelContent = document.getElementById('literaturePanelContent');
            const scrollIndicator = document.getElementById('literatureScrollIndicator');

            if (!panelContent || !scrollIndicator) return;

            let isUpdating = false;

            function updateScrollIndicator() {
                if (isUpdating) return;
                isUpdating = true;

                try {
                    const hasScroll = panelContent.scrollHeight > panelContent.clientHeight + 5;
                    const isAtBottom = panelContent.scrollTop + panelContent.clientHeight >= panelContent.scrollHeight - 10;

                    if (hasScroll && !isAtBottom) {
                        scrollIndicator.classList.add('show');
                        panelContent.classList.add('has-scroll');
                    } else {
                        scrollIndicator.classList.remove('show');
                        panelContent.classList.remove('has-scroll');
                    }
                } catch (error) {
                    console.error('更新滚动指示器时出错:', error);
                } finally {
                    isUpdating = false;
                }
            }

            let scrollTimeout;
            function throttledUpdate() {
                if (scrollTimeout) return;
                scrollTimeout = setTimeout(() => {
                    updateScrollIndicator();
                    scrollTimeout = null;
                }, 100);
            }

            panelContent.addEventListener('scroll', throttledUpdate);

            let resizeTimeout;
            const resizeObserver = new ResizeObserver(() => {
                if (resizeTimeout) return;
                resizeTimeout = setTimeout(() => {
                    updateScrollIndicator();
                    resizeTimeout = null;
                }, 200);
            });
            resizeObserver.observe(panelContent);

            setTimeout(updateScrollIndicator, 500);

            panelContent.addEventListener('keydown', (e) => {
                if (e.target === panelContent || panelContent.contains(e.target)) {
                    switch(e.key) {
                        case 'PageDown':
                            e.preventDefault();
                            panelContent.scrollBy(0, panelContent.clientHeight * 0.8);
                            break;
                        case 'PageUp':
                            e.preventDefault();
                            panelContent.scrollBy(0, -panelContent.clientHeight * 0.8);
                            break;
                        case 'Home':
                            if (e.ctrlKey) {
                                e.preventDefault();
                                panelContent.scrollTo(0, 0);
                            }
                            break;
                        case 'End':
                            if (e.ctrlKey) {
                                e.preventDefault();
                                panelContent.scrollTo(0, panelContent.scrollHeight);
                            }
                            break;
                    }
                }
            });

        }

        function scrollLiteraturePanel(direction) {
            const panelContent = document.getElementById('literaturePanelContent');
            if (!panelContent) return;

            const scrollAmount = panelContent.clientHeight * 0.5;
            const targetScroll = direction === 'down' ? scrollAmount : -scrollAmount;

            panelContent.scrollBy({
                top: targetScroll,
                behavior: 'smooth'
            });
        }

        function scrollLiteraturePanelToTop() {
            const panelContent = document.getElementById('literaturePanelContent');
            if (!panelContent) return;

            panelContent.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        function scrollLiteraturePanelToBottom() {
            const panelContent = document.getElementById('literaturePanelContent');
            if (!panelContent) return;

            panelContent.scrollTo({
                top: panelContent.scrollHeight,
                behavior: 'smooth'
            });
        }

        setTimeout(emergencyFixTabs, 100);

        function testLiteratureScroll() {
            const panelContent = document.getElementById('literaturePanelContent');
            if (panelContent) {
                console.log('文献助手滚动信息:', {
                    scrollHeight: panelContent.scrollHeight,
                    clientHeight: panelContent.clientHeight,
                    scrollTop: panelContent.scrollTop,
                    canScroll: panelContent.scrollHeight > panelContent.clientHeight
                });

                panelContent.scrollTo({
                    top: panelContent.scrollHeight,
                    behavior: 'smooth'
                });
            }
        }

        window.testLiteratureScroll = testLiteratureScroll;

        function initLiteratureSidebar() {
            const sidebar = document.getElementById('literatureSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const openBtn = document.getElementById('sidebarOpenBtn');
            const toggleBtn = document.getElementById('literatureSidebarToggle');
            const btnText = document.getElementById('sidebarBtnText');

            if (!sidebar || !overlay || !openBtn || !toggleBtn) {
                console.warn('侧边栏元素未找到');
                return;
            }

            function updateButtonState(isOpen) {
                if (btnText) {
                    btnText.textContent = isOpen ? '关闭助手' : '文献助手';
                }
                if (openBtn) {
                    openBtn.title = isOpen ? '关闭文献阅读助手' : '打开文献阅读助手';
                    openBtn.style.background = isOpen ? '#28a745' : '';
                }
            }

            function openSidebar() {
                sidebar.classList.add('open');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
                updateButtonState(true);
            }

            function closeSidebar() {
                sidebar.classList.remove('open');
                overlay.classList.remove('active');
                document.body.style.overflow = '';
                updateButtonState(false);
            }

            function toggleSidebar() {
                if (sidebar.classList.contains('open')) {
                    closeSidebar();
                } else {
                    openSidebar();
                }
            }

            openBtn.addEventListener('click', toggleSidebar);
            toggleBtn.addEventListener('click', closeSidebar);
            overlay.addEventListener('click', closeSidebar);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && sidebar.classList.contains('open')) {
                    closeSidebar();
                }
            });

            updateButtonState(false);

            console.log('文献助手侧边栏已初始化');
        }

        function initPDFViewerResize() {
            const container = document.getElementById('pdfViewerContainer');
            const header = document.getElementById('pdfViewerHeader');
            const rightHandle = document.getElementById('pdfResizeRight');
            const bottomHandle = document.getElementById('pdfResizeBottom');
            const cornerHandle = document.getElementById('pdfResizeCorner');

            if (!container || !header || !rightHandle || !bottomHandle || !cornerHandle) {
                console.warn('PDF预览框元素未找到');
                return;
            }

            let isResizing = false;
            let isDragging = false;
            let resizeType = '';
            let startX, startY, startWidth, startHeight, startLeft, startTop;
            let dragOffsetX, dragOffsetY;

            function startResize(e, type) {
                isResizing = true;
                resizeType = type;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(window.getComputedStyle(container).width, 10);
                startHeight = parseInt(window.getComputedStyle(container).height, 10);
                startLeft = container.offsetLeft;
                startTop = container.offsetTop;

                container.classList.add('resizing');
                document.body.style.cursor = type === 'right' ? 'ew-resize' :
                                           type === 'bottom' ? 'ns-resize' : 'nw-resize';

                e.preventDefault();
                e.stopPropagation();
            }

            function startDrag(e) {
                if (e.target.closest('.pdf-resize-handle')) return;

                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.closest('input') || e.target.closest('button')) {
                    return;
                }

                isDragging = true;

                startX = e.clientX;
                startY = e.clientY;

                startLeft = container.offsetLeft;
                startTop = container.offsetTop;

                container.classList.add('dragging');
                document.body.style.cursor = 'move';

                e.preventDefault();
            }

            function handleMouseMove(e) {
                if (isResizing) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    let newWidth = startWidth;
                    let newHeight = startHeight;

                    if (resizeType === 'right' || resizeType === 'corner') {
                        newWidth = Math.max(300, startWidth + deltaX);
                        newWidth = Math.min(window.innerWidth - startLeft, newWidth);
                    }

                    if (resizeType === 'bottom' || resizeType === 'corner') {
                        newHeight = Math.max(200, startHeight + deltaY);
                        newHeight = Math.min(window.innerHeight - startTop, newHeight);
                    }

                    container.style.width = newWidth + 'px';
                    container.style.height = newHeight + 'px';

                } else if (isDragging) {

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;

                    const containerWidth = container.offsetWidth;
                    const containerHeight = container.offsetHeight;
                    const minVisible = 50;

                    newLeft = Math.max(-containerWidth + minVisible, newLeft);
                    newLeft = Math.min(window.innerWidth - minVisible, newLeft);
                    newTop = Math.max(-containerHeight + minVisible, newTop);
                    newTop = Math.min(window.innerHeight - minVisible, newTop);

                    container.style.left = newLeft + 'px';
                    container.style.top = newTop + 'px';
                }
            }

            function endResize() {
                if (isResizing || isDragging) {
                    isResizing = false;
                    isDragging = false;
                    resizeType = '';

                    container.classList.remove('resizing', 'dragging');
                    document.body.style.cursor = '';
                }
            }

            rightHandle.addEventListener('mousedown', (e) => startResize(e, 'right'));
            bottomHandle.addEventListener('mousedown', (e) => startResize(e, 'bottom'));
            cornerHandle.addEventListener('mousedown', (e) => startResize(e, 'corner'));
            header.addEventListener('mousedown', startDrag);

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', endResize);

            console.log('PDF预览框调整大小和移动功能已初始化');
        }

        setTimeout(initLiteratureSidebar, 100);

        async function loadPDFFromUrl(url) {
            try {
                showStatus('正在加载URL...', 'info');

                let validUrl;
                try {
                    validUrl = new URL(url);
                } catch (e) {

                    if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        url = 'https://' + url;
                        validUrl = new URL(url);
                    } else {
                        throw e;
                    }
                }

                console.log('加载URL:', validUrl.href);

                const isPDF = validUrl.pathname.toLowerCase().endsWith('.pdf') ||
                             validUrl.href.toLowerCase().includes('.pdf') ||
                             validUrl.searchParams.get('type') === 'pdf';

                if (isPDF) {

                    showStatus('正在下载PDF文件...', 'info');

                    try {
                        const response = await fetch(validUrl.href, {
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/pdf'
                            }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const arrayBuffer = await response.arrayBuffer();
                        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });

                        const fileName = validUrl.pathname.split('/').pop() || 'document.pdf';
                        const file = new File([blob], fileName, { type: 'application/pdf' });

                        if (!pdfViewerContainer.classList.contains('active')) {
                            pdfViewerContainer.classList.add('active');
                        }

                        pdfViewerContainer.removeAttribute('data-mode');

                        await loadPDFFile(file);
                        showStatus(`PDF已从URL加载: ${fileName}`, 'success');

                        if (pdfUrlInput) {
                            pdfUrlInput.value = '';
                        }

                    } catch (fetchError) {

                        console.warn('直接下载失败，尝试iframe方式:', fetchError);
                        loadPDFInIframe(validUrl.href);
                    }

                } else {

                    showStatus('检测到网页URL，在预览框中显示', 'info');
                    loadWebPageInViewer(validUrl.href);
                }

            } catch (error) {
                console.error('URL加载失败:', error);
                let errorMessage = '加载URL失败: ';

                if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                    errorMessage += '无法访问该URL，可能是CORS限制或网络问题';
                } else if (error.message.includes('Invalid URL')) {
                    errorMessage += '无效的URL格式';
                } else {
                    errorMessage += error.message;
                }

                showStatus(errorMessage, 'error');
            }
        }

        function loadPDFInIframe(url) {
            try {

                if (!pdfViewerContainer.classList.contains('active')) {
                    pdfViewerContainer.classList.add('active');
                }

                const pdfContent = document.querySelector('.pdf-viewer-content');
                if (pdfContent) {
                    pdfContent.innerHTML = `
                        <div style="width: 100%; height: 100%; display: flex; flex-direction: column;">
                            <div style="padding: 10px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; font-size: 14px;">
                                📄 PDF预览 - <a href="${url}" target="_blank" style="color: #007bff;">在新标签页中打开</a>
                            </div>
                            <iframe src="${url}" style="width: 100%; height: 100%; border: none; flex: 1;"></iframe>
                        </div>
                    `;
                }

                const pdfTitle = document.getElementById('pdfViewerTitle');
                if (pdfTitle) {
                    const fileName = url.split('/').pop() || 'PDF文档';
                    pdfTitle.textContent = `PDF预览 - ${fileName}`;
                }

                pdfViewerContainer.setAttribute('data-mode', 'pdf-iframe');

                showStatus('PDF已在预览框中加载', 'success');

            } catch (error) {
                console.error('iframe加载失败:', error);
                showStatus('PDF加载失败: ' + error.message, 'error');
            }
        }

        function loadWebPageInViewer(url) {
            try {

                if (!pdfViewerContainer.classList.contains('active')) {
                    pdfViewerContainer.classList.add('active');
                }

                const pdfContent = document.querySelector('.pdf-viewer-content');
                if (pdfContent) {
                    pdfContent.innerHTML = `
                        <div id="webPageContainer" style="width: 100%; height: 100%; display: flex; flex-direction: column; position: relative;">
                            <div style="padding: 10px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; font-size: 14px; display: flex; justify-content: space-between; align-items: center;">
                                <span>🌐 网页预览 - <a href="${url}" target="_blank" style="color: #007bff;">在新标签页中打开</a></span>
                                <div>
                                    <button id="webPageScreenshot" class="pdf-control-btn" title="截图网页" style="margin-right: 5px;">📷</button>
                                    <button id="webPageRefresh" class="pdf-control-btn" title="刷新网页">🔄</button>
                                </div>
                            </div>
                            <iframe id="webPageIframe" src="${url}" style="width: 100%; height: 100%; border: none; flex: 1;"></iframe>
                        </div>
                    `;
                }

                setTimeout(() => {
                    const screenshotBtn = document.getElementById('webPageScreenshot');
                    const refreshBtn = document.getElementById('webPageRefresh');
                    const iframe = document.getElementById('webPageIframe');

                    if (screenshotBtn) {
                        screenshotBtn.addEventListener('click', () => {
                            captureWebPageScreenshot();
                        });
                    }

                    if (refreshBtn) {
                        refreshBtn.addEventListener('click', () => {
                            if (iframe) {
                                iframe.src = iframe.src;
                                showStatus('网页已刷新', 'info');
                            }
                        });
                    }
                }, 100);

                const pdfTitle = document.getElementById('pdfViewerTitle');
                if (pdfTitle) {
                    const domain = new URL(url).hostname;
                    pdfTitle.textContent = `网页预览 - ${domain}`;
                }

                pdfViewerContainer.setAttribute('data-mode', 'webpage');

                showStatus('网页已在预览框中加载', 'success');

            } catch (error) {
                console.error('网页加载失败:', error);
                showStatus('网页加载失败: ' + error.message, 'error');
            }
        }

        function captureWebPageScreenshot() {
            try {
                const webContainer = document.getElementById('webPageContainer');
                const iframe = document.getElementById('webPageIframe');

                if (!webContainer || !iframe) {
                    showStatus('无法找到网页容器', 'error');
                    return;
                }

                if (window.isCapturingWebPageScreenshot) {
                    showStatus('截图正在进行中，请稍候...', 'warning');
                    return;
                }

                window.isCapturingWebPageScreenshot = true;

                showStatus('请按以下步骤操作：1. 选择要录制的浏览器窗口 2. 在预览框中拖拽选择区域', 'info');

                startWebPageScreenCapture();

            } catch (error) {
                console.error('截图功能出错:', error);
                showStatus('截图功能出错: ' + error.message, 'error');
                window.isCapturingWebPageScreenshot = false;
            }
        }

        function startWebPageScreenCapture() {

            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                showStatus('浏览器不支持屏幕录制功能', 'error');
                return;
            }

            showStatus('请选择要截图的浏览器窗口，然后点击预览框中的区域进行截图', 'info');

            navigator.mediaDevices.getDisplayMedia({
                video: {
                    mediaSource: 'screen',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 }
                }
            })
            .then(stream => {

                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();

                enableWebPageAreaSelection(video, stream);

            })
            .catch(error => {
                console.error('屏幕录制失败:', error);
                if (error.name === 'NotAllowedError') {
                    showStatus('用户取消了屏幕录制权限', 'warning');
                } else {
                    showStatus('屏幕录制失败: ' + error.message, 'error');
                }
            });
        }

        function enableWebPageAreaSelection(video, stream) {
            const webContainer = document.getElementById('webPageContainer');
            if (!webContainer) return;

            const overlay = document.createElement('div');
            overlay.id = 'webPageScreenshotOverlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.3);
                cursor: crosshair;
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 16px;
                text-align: center;
                pointer-events: auto;
            `;
            overlay.innerHTML = `
                <div style="background: rgba(0, 0, 0, 0.8); padding: 20px; border-radius: 8px;">
                    <div>📷 区域截图模式</div>
                    <div style="font-size: 14px; margin-top: 10px;">拖拽选择要截图的区域</div>
                    <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">按ESC键取消</div>
                </div>
            `;

            webContainer.appendChild(overlay);

            let isSelecting = false;
            let startX, startY, endX, endY;
            let selectionDiv;

            overlay.addEventListener('mousedown', (e) => {
                isSelecting = true;
                const rect = overlay.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;

                overlay.innerHTML = '';

                selectionDiv = document.createElement('div');
                selectionDiv.style.cssText = `
                    position: absolute;
                    border: 2px dashed #00ff00;
                    background: rgba(0, 255, 0, 0.1);
                    pointer-events: none;
                `;
                overlay.appendChild(selectionDiv);

                e.preventDefault();
            });

            overlay.addEventListener('mousemove', (e) => {
                if (!isSelecting || !selectionDiv) return;

                const rect = overlay.getBoundingClientRect();
                endX = e.clientX - rect.left;
                endY = e.clientY - rect.top;

                const left = Math.min(startX, endX);
                const top = Math.min(startY, endY);
                const width = Math.abs(endX - startX);
                const height = Math.abs(endY - startY);

                selectionDiv.style.left = left + 'px';
                selectionDiv.style.top = top + 'px';
                selectionDiv.style.width = width + 'px';
                selectionDiv.style.height = height + 'px';

                if (width > 5 && height > 5) {
                    selectionDiv.innerHTML = `<div style="position: absolute; top: -25px; left: 0; background: rgba(0, 0, 0, 0.8); color: white; padding: 2px 6px; border-radius: 3px; font-size: 12px; white-space: nowrap;">${Math.round(width)} × ${Math.round(height)}</div>`;
                }
            });

            overlay.addEventListener('mouseup', (e) => {
                if (!isSelecting) return;
                isSelecting = false;

                const rect = overlay.getBoundingClientRect();
                endX = e.clientX - rect.left;
                endY = e.clientY - rect.top;

                const left = Math.min(startX, endX);
                const top = Math.min(startY, endY);
                const width = Math.abs(endX - startX);
                const height = Math.abs(endY - startY);

                console.log('📷 网页截图区域选择:', {
                    startX, startY, endX, endY,
                    left, top, width, height,
                    overlaySize: { width: rect.width, height: rect.height }
                });

                if (width > 5 && height > 5) {

                    if (webContainer.contains(overlay)) {
                        webContainer.removeChild(overlay);
                    }

                    setTimeout(() => {
                        captureScreenArea(video, stream, left, top, width, height);
                    }, 100);
                } else {
                    console.log('📷 选择区域太小:', { width, height });
                    showStatus(`选择区域太小 (${Math.round(width)}×${Math.round(height)})，请重新选择`, 'warning');

                    setTimeout(() => {
                        if (webContainer.contains(overlay)) {
                            webContainer.removeChild(overlay);
                        }

                        stream.getTracks().forEach(track => track.stop());
                    }, 2000);
                    return;
                }
            });

            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    if (webContainer.contains(overlay)) {
                        webContainer.removeChild(overlay);
                    }
                    stream.getTracks().forEach(track => track.stop());
                    document.removeEventListener('keydown', escHandler);
                    window.isCapturingWebPageScreenshot = false;
                    showStatus('截图已取消', 'info');
                }
            };
            document.addEventListener('keydown', escHandler);
        }

        function captureScreenArea(video, stream, left, top, width, height, retryCount = 0) {
            console.log('📷 开始处理截图区域:', { left, top, width, height, retryCount });

            function processScreenCapture() {
                try {
                    showStatus('正在处理截图...', 'info');

                    const videoWidth = video.videoWidth;
                    const videoHeight = video.videoHeight;

                    console.log('📷 视频尺寸:', { videoWidth, videoHeight });

                    if (videoWidth === 0 || videoHeight === 0) {
                        if (retryCount < 3) {
                            console.log('📷 视频尺寸无效，重试中...', retryCount + 1);
                            setTimeout(() => {
                                captureScreenArea(video, stream, left, top, width, height, retryCount + 1);
                            }, 500);
                            return;
                        } else {
                            throw new Error('视频尺寸无效，重试失败');
                        }
                    }

                    console.log('📷 用户选择的区域:', { left, top, width, height });

                    const webContainer = document.getElementById('webPageContainer');
                    if (!webContainer) {
                        throw new Error('找不到网页容器');
                    }

                    const containerRect = webContainer.getBoundingClientRect();
                    console.log('📷 容器信息:', {
                        width: containerRect.width,
                        height: containerRect.height,
                        left: containerRect.left,
                        top: containerRect.top
                    });

                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;

                    let browserUIHeight = window.outerHeight - window.innerHeight;

                    if (window.customBrowserUIHeight) {
                        browserUIHeight = window.customBrowserUIHeight;
                        console.log('📷 使用自定义UI高度:', browserUIHeight);
                    } else if (browserUIHeight < 0 || browserUIHeight > 200) {

                        browserUIHeight = 85;
                        console.log('📷 使用默认UI高度:', browserUIHeight);
                    }

                    console.log('📷 浏览器尺寸信息:', {
                        windowWidth,
                        windowHeight,
                        outerHeight: window.outerHeight,
                        innerHeight: window.innerHeight,
                        browserUIHeight: browserUIHeight
                    });

                    const containerInWindowLeft = containerRect.left;
                    const containerInWindowTop = containerRect.top;

                    const selectionInWindowLeft = containerInWindowLeft + left;
                    const selectionInWindowTop = containerInWindowTop + top;

                    console.log('📷 选择区域在窗口中的位置:', {
                        selectionInWindowLeft,
                        selectionInWindowTop,
                        width,
                        height
                    });

                    const scaleX = videoWidth / windowWidth;

                    const scaleY = videoHeight / (windowHeight + browserUIHeight);

                    console.log('📷 视频到窗口的缩放比例:', { scaleX, scaleY });

                    const actualLeft = Math.max(0, Math.round(selectionInWindowLeft * scaleX));

                    const actualTop = Math.max(0, Math.round((selectionInWindowTop + browserUIHeight) * scaleY));
                    const actualWidth = Math.min(Math.round(width * scaleX), videoWidth - actualLeft);
                    const actualHeight = Math.min(Math.round(height * scaleY), videoHeight - actualTop);

                    console.log('📷 实际截图区域:', { actualLeft, actualTop, actualWidth, actualHeight });

                    if (actualWidth <= 0 || actualHeight <= 0) {
                        throw new Error('截图区域计算错误');
                    }

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = actualWidth;
                    canvas.height = actualHeight;

                    ctx.drawImage(
                        video,
                        actualLeft, actualTop, actualWidth, actualHeight,
                        0, 0, actualWidth, actualHeight
                    );

                    console.log('📷 截图绘制完成，canvas尺寸:', { width: canvas.width, height: canvas.height });

                    stream.getTracks().forEach(track => track.stop());

                    canvas.toBlob(blob => {
                        if (blob && blob.size > 1000) {
                            console.log('📷 截图blob生成成功，大小:', blob.size);
                            window.isCapturingWebPageScreenshot = false;
                            showWebPageScreenshotOptions(blob);
                        } else {
                            console.error('📷 截图blob生成失败或过小:', blob ? blob.size : 'null');
                            if (retryCount < 2) {
                                showStatus(`截图质量检查失败，重试中... (${retryCount + 1}/3)`, 'warning');
                                setTimeout(() => {
                                    captureScreenArea(video, stream, left, top, width, height, retryCount + 1);
                                }, 1000);
                            } else {
                                showStatus('截图生成失败，请重新尝试', 'error');
                                window.isCapturingWebPageScreenshot = false;
                                stream.getTracks().forEach(track => track.stop());
                            }
                        }
                    }, 'image/png', 0.95);

                } catch (error) {
                    console.error('📷 截图处理失败:', error);
                    showStatus('截图处理失败: ' + error.message, 'error');
                    stream.getTracks().forEach(track => track.stop());
                }
            }

            if (video.readyState >= 2) {
                console.log('📷 视频已加载，直接处理');
                processScreenCapture();
            } else {
                console.log('📷 等待视频加载...', { readyState: video.readyState });

                const loadHandler = () => {
                    console.log('📷 视频加载完成');
                    processScreenCapture();
                };

                video.addEventListener('loadedmetadata', loadHandler, { once: true });
                video.addEventListener('loadeddata', loadHandler, { once: true });
                video.addEventListener('canplay', loadHandler, { once: true });

                video.play().catch(e => {
                    console.log('📷 视频播放失败，但继续尝试:', e.message);
                });

                setTimeout(() => {
                    if (video.readyState < 2) {
                        console.error('📷 视频加载超时，readyState:', video.readyState);
                        if (retryCount < 2) {
                            showStatus(`视频加载超时，重试中... (${retryCount + 1}/3)`, 'warning');
                            setTimeout(() => {
                                captureScreenArea(video, stream, left, top, width, height, retryCount + 1);
                            }, 1000);
                        } else {
                            showStatus('视频加载失败，请重新截图', 'error');
                            stream.getTracks().forEach(track => track.stop());
                        }
                    }
                }, 3000);
            }
        }

        function showWebPageScreenshotOptions(blob) {
            console.log('📷 显示截图选项对话框，blob大小:', blob.size);

            window.currentWebPageScreenshotBlob = blob;

            const dialog = document.getElementById('screenshotOptionsDialog');
            console.log('📷 截图选项对话框元素:', !!dialog);

            if (dialog) {

                const uploadToChat = document.getElementById('uploadToChat');
                const saveToLocal = document.getElementById('saveToLocal');
                const fileName = document.getElementById('screenshotFileName');

                console.log('📷 对话框元素状态:', {
                    uploadToChat: !!uploadToChat,
                    saveToLocal: !!saveToLocal,
                    fileName: !!fileName
                });

                if (uploadToChat) uploadToChat.checked = true;
                if (saveToLocal) saveToLocal.checked = false;
                if (fileName) {
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    fileName.value = `webpage-screenshot-${timestamp}`;
                }

                dialog.style.display = 'block';
                showStatus('请选择截图处理方式', 'info');
                console.log('📷 截图选项对话框已显示');
            } else {
                console.log('📷 未找到截图选项对话框，直接上传');

                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const fileName = `webpage-screenshot-${timestamp}.png`;
                console.log('📷 直接上传截图，文件名:', fileName);
                uploadScreenshot(blob, fileName);
            }
        }

        function uploadScreenshot(blob, fileName = 'screenshot.png') {
            try {
                console.log('📷 uploadScreenshot调用，参数:', {
                    blobSize: blob ? blob.size : 'null',
                    fileName: fileName
                });

                if (!blob) {
                    console.error('📷 截图数据无效');
                    showStatus('截图数据无效', 'error');
                    return;
                }

                const cleanFileName = fileName.replace('.png', '');
                console.log('📷 调用processWebPageScreenshot，文件名:', cleanFileName);
                processWebPageScreenshot(blob, true, false, cleanFileName);

            } catch (error) {
                console.error('📷 网页截图上传失败:', error);
                showStatus('网页截图上传失败: ' + error.message, 'error');
            }
        }

        setTimeout(initPDFViewerResize, 200);

        async function searchPDFText(query) {
            return performPDFSearch(query);
        }

        function updatePDFSearchResults() {

            const pdfSearchResults = document.getElementById('pdfSearchResults');
            if (!pdfSearchResults) {
                console.log('pdfSearchResults element not found, skipping update');
                return;
            }

            pdfSearchResults.innerHTML = '';

            if (pdfSearchResultsData.length === 0) {
                pdfSearchResults.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">未找到匹配结果</div>';
                return;
            }

            pdfSearchResultsData.forEach(result => {
                const item = document.createElement('div');
                item.className = 'pdf-annotation-item';
                item.innerHTML = '<div class="pdf-annotation-text">"' + result.text + '"</div><div class="pdf-annotation-page">页面 ' + result.page + '</div><div style="font-size: 12px; color: #666; margin-top: 5px;">...' + result.context + '...</div>';

                item.addEventListener('click', () => {
                    if (result.page !== currentPage) {
                        renderPDFPage(result.page);
                    }
                });

                pdfSearchResults.appendChild(item);
            });
        }

        function showConfirmDialog(title, message, callback) {
            dialogTitle.textContent = title;
            dialogMessage.textContent = message;
            confirmDialog.classList.add('visible');

            dialogConfirm.onclick = () => {
                confirmDialog.classList.remove('visible');
                callback(true);
            };

            dialogCancel.onclick = () => {
                confirmDialog.classList.remove('visible');
                callback(false);
            };
        }

        contextLength.addEventListener('input', () => {
            const length = parseInt(contextLength.value);
            contextLengthDesc.textContent = '保留最近' + length + '条消息作为上下文';
            saveConfig();
        });

        advancedToggle.addEventListener('click', () => {
            if (advancedSettings.style.display === 'block') {
                advancedSettings.style.display = 'none';
                advancedToggle.textContent = '显示高级设置 ▼';
            } else {
                advancedSettings.style.display = 'block';
                advancedToggle.textContent = '隐藏高级设置 ▲';
            }
        });

        selectionModeCheckbox.addEventListener('change', () => {
            selectionMode = selectionModeCheckbox.checked;

            if (selectionMode) {
                bulkControls.classList.add('visible');
                chatContainer.querySelectorAll('.message').forEach(msg => {
                    msg.style.cursor = 'pointer';
                });
            } else {
                bulkControls.classList.remove('visible');
                selectedMessages.clear();
                updateSelectedCount();
                chatContainer.querySelectorAll('.message').forEach(msg => {
                    msg.style.cursor = '';
                    msg.classList.remove('selected');
                });
            }
        });

        cancelSelectButton.addEventListener('click', () => {
            selectionModeCheckbox.checked = false;
            selectionMode = false;
            bulkControls.classList.remove('visible');
            selectedMessages.clear();
            updateSelectedCount();
            chatContainer.querySelectorAll('.message').forEach(msg => {
                msg.style.cursor = '';
                msg.classList.remove('selected');
            });
        });

        bulkDeleteButton.addEventListener('click', () => {
            if (selectedMessages.size === 0) return;

            showConfirmDialog(
                '确认删除',
                '确定要删除已选择的 ' + selectedMessages.size + ' 条消息吗？',
                (confirmed) => {
                    if (confirmed) {
                        deleteSelectedMessages();
                    }
                }
            );
        });

        function updateSelectedCount() {
            selectedCount.textContent = '已选择 ' + selectedMessages.size + ' 条消息';
        }

        function loadConfig() {
            const savedApiUrl = localStorage.getItem('apiUrl');
            const savedApiKey = localStorage.getItem('apiKey');
            const savedModel = localStorage.getItem('model');
            const savedTemp = localStorage.getItem('temperature');
            const savedStream = localStorage.getItem('stream');
            const savedDirection = localStorage.getItem('textDirection');
            const savedSystemPrompt = localStorage.getItem('systemPrompt');
            const savedMaxTokens = localStorage.getItem('maxTokens');
            const savedContextLength = localStorage.getItem('contextLength');

            if (savedApiUrl) apiUrlInput.value = savedApiUrl;
            if (savedApiKey) apiKeyInput.value = savedApiKey;
            if (savedModel) modelSelect.value = savedModel;
            if (savedTemp) {
                tempSlider.value = savedTemp;
                tempValue.textContent = savedTemp;
            }
            if (savedStream !== null) streamCheckbox.checked = savedStream === 'true';
            if (savedDirection) textDirectionSelect.value = savedDirection;
            if (savedSystemPrompt) systemPrompt.value = savedSystemPrompt;
            if (savedMaxTokens) maxTokens.value = savedMaxTokens;
            if (savedContextLength) {
                contextLength.value = savedContextLength;
                contextLengthDesc.textContent = '保留最近' + savedContextLength + '条消息作为上下文';
            }

            const savedHistory = localStorage.getItem('conversationHistory');
            if (savedHistory) {
                try {
                    const parsedHistory = JSON.parse(savedHistory);

                    conversationHistory = parsedHistory.map(msg => {
                        if (!msg.id && msg.role !== 'system') {
                            msg.id = generateMessageId();
                        }
                        return msg;
                    });

                    conversationHistory.forEach(msg => {
                        if (msg.role === 'system') return;
                        addMessageToUI(msg.role, msg.content, msg.id, msg.originalContent);
                    });
                } catch (e) {
                    console.error('无法加载历史对话:', e);
                }
            }
        }

        function generateMessageId() {
            return 'msg_' + Date.now() + '_' + (messageCounter++);
        }

        function saveConfig() {
            localStorage.setItem('apiUrl', apiUrlInput.value);
            localStorage.setItem('apiKey', apiKeyInput.value);
            localStorage.setItem('model', modelSelect.value);
            localStorage.setItem('temperature', tempSlider.value);
            localStorage.setItem('stream', streamCheckbox.checked);
            localStorage.setItem('textDirection', textDirectionSelect.value);
            localStorage.setItem('systemPrompt', systemPrompt.value);
            localStorage.setItem('maxTokens', maxTokens.value);
            localStorage.setItem('contextLength', contextLength.value);

            localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory));
        }

        function showStatus(message, type = 'info') {
            statusMessage.className = type === 'error' ? 'error-message' : 'success-message';
            statusMessage.textContent = message;
            setTimeout(() => {
                statusMessage.textContent = '';
            }, 3000);
        }

        function showCopyToast() {
            copyToast.style.opacity = '1';
            setTimeout(() => {
                copyToast.style.opacity = '0';
            }, 2000);
        }

        function detectTextDirection(text) {

            return rtlRegex.test(text) ? 'rtl' : 'ltr';
        }

        function deleteSelectedMessages() {

            const idsToDelete = Array.from(selectedMessages);

            idsToDelete.forEach(id => {
                deleteMessage(id);
            });

            selectedMessages.clear();
            updateSelectedCount();

            if (selectionModeCheckbox.checked && selectedMessages.size === 0) {
                selectionModeCheckbox.checked = false;
                selectionMode = false;
                bulkControls.classList.remove('visible');
            }

            showStatus('已删除 ' + idsToDelete.length + ' 条消息', 'success');

            saveConfig();
        }

        function deleteMessage(messageId) {

            const messageElement = messageElements.get(messageId);
            if (messageElement) {
                messageElement.classList.add('deleting');
                setTimeout(() => {
                    messageElement.remove();
                    messageElements.delete(messageId);
                }, 300);
            }

            const messageIndex = conversationHistory.findIndex(msg => msg.id === messageId);
            if (messageIndex !== -1) {
                conversationHistory.splice(messageIndex, 1);
            }

            if (selectedMessages.has(messageId)) {
                selectedMessages.delete(messageId);
                updateSelectedCount();
            }
        }

        function addMessageToUI(role, content, messageId = null, originalContent = null) {
            if (!messageId) {
                messageId = generateMessageId();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + role;
            messageDiv.dataset.id = messageId;

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = role === 'user' ? '用户' : 'AI';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            const direction = textDirectionSelect.value;

            if (direction === 'rtl' || (direction === 'auto' && detectTextDirection(content) === 'rtl')) {
                contentDiv.classList.add('rtl');
            }

            if (role === 'assistant') {

                contentDiv.innerHTML = parseMarkdown(content);
            } else {

                contentDiv.textContent = content;
            }

            const timestamp = document.createElement('div');
            timestamp.className = 'message-timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            contentDiv.appendChild(timestamp);

            const deleteButton = document.createElement('button');
            deleteButton.className = 'delete-button';
            deleteButton.innerHTML = '×';
            deleteButton.title = '删除此消息';
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();

                showConfirmDialog(
                    '确认删除',
                    '确定要删除这条消息吗？',
                    (confirmed) => {
                        if (confirmed) {
                            deleteMessage(messageId);
                            saveConfig();
                        }
                    }
                );
            });

            if (role === 'user') {
                const editButton = document.createElement('button');
                editButton.className = 'edit-button';
                editButton.innerHTML = '✎';
                editButton.title = '编辑此消息';
                editButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editMessage(messageId);
                });
                messageDiv.appendChild(editButton);
            }

            if (role === 'user') {
                const resendButton = document.createElement('button');
                resendButton.className = 'resend-button';
                resendButton.innerHTML = '↻';
                resendButton.title = '重新发送此消息';
                resendButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    resendMessage(messageId);
                });
                messageDiv.appendChild(resendButton);
            }

            if (role === 'assistant') {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';

                const copyButton = document.createElement('button');
                copyButton.className = 'action-btn';
                copyButton.textContent = '复制';
                copyButton.addEventListener('click', (e) => {
                    e.stopPropagation();

                    const plainText = extractPlainText(contentDiv.innerHTML);

                    navigator.clipboard.writeText(plainText)
                        .then(() => {
                            showCopyToast();
                        })
                        .catch(err => {
                            console.error('复制失败:', err);
                            showStatus('复制失败', 'error');
                        });
                });

                if ('speechSynthesis' in window) {
                    const speakButton = document.createElement('button');
                    speakButton.className = 'action-btn';
                    speakButton.textContent = '朗读';
                    speakButton.addEventListener('click', (e) => {
                        e.stopPropagation();

                        window.speechSynthesis.cancel();

                        const plainText = extractPlainText(contentDiv.innerHTML);
                        const utterance = new SpeechSynthesisUtterance(plainText);

                        if (contentDiv.classList.contains('rtl')) {
                            utterance.lang = 'ar';
                        }
                        window.speechSynthesis.speak(utterance);
                    });
                    actionsDiv.appendChild(speakButton);
                }

                actionsDiv.appendChild(copyButton);
                contentDiv.appendChild(actionsDiv);
            }

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(deleteButton);

            messageDiv.addEventListener('click', () => {
                if (!selectionMode) return;

                if (selectedMessages.has(messageId)) {
                    selectedMessages.delete(messageId);
                    messageDiv.classList.remove('selected');
                } else {
                    selectedMessages.add(messageId);
                    messageDiv.classList.add('selected');
                }

                updateSelectedCount();
            });

            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            messageElements.set(messageId, messageDiv);

            return { contentDiv, messageId, originalContent };
        }

        function processMessageContent(contentDiv) {

            const images = contentDiv.querySelectorAll('img');
            images.forEach(img => {

                img.style.maxWidth = '30%';
                img.style.height = 'auto';
                img.style.maxHeight = '300px';
                img.style.objectFit = 'contain';

                img.addEventListener('load', function () {

                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
            });
        }

        function editMessage(messageId) {
            const message = conversationHistory.find(msg => msg.id === messageId);
            if (!message || message.role !== 'user') return;

            currentEditingMessageId = messageId;

            const contentToEdit = message.originalContent || message.content;

            messageInput.value = contentToEdit;
            messageInput.focus();

            autoResizeTextarea(messageInput);

            sendButton.textContent = '更新';

            showStatus('正在编辑消息，按更新保存修改', 'info');
        }

        function resendMessage(messageId) {
            const message = conversationHistory.find(msg => msg.id === messageId);
            if (!message || message.role !== 'user') return;

            const messageIndex = conversationHistory.findIndex(msg => msg.id === messageId);
            if (messageIndex === -1) return;

            showConfirmDialog(
                '确认重新发送',
                '重新发送此消息将删除此消息之后的所有对话。确定继续吗？',
                async (confirmed) => {
                    if (confirmed) {

                        for (let i = conversationHistory.length - 1; i > messageIndex; i--) {
                            const msgToDelete = conversationHistory[i];
                            deleteMessage(msgToDelete.id);
                        }

                        const contentToResend = message.originalContent || message.content;

                        deleteMessage(messageId);

                        messageInput.value = contentToResend;

                        autoResizeTextarea(messageInput);

                        await sendMessage();
                    }
                }
            );
        }

        function addMessage(role, content, originalContent = null) {
            const messageId = generateMessageId();
            const { contentDiv } = addMessageToUI(role, content, messageId, originalContent);

            conversationHistory.push({
                role,
                content,
                id: messageId,
                originalContent
            });

            return { contentDiv, messageId };
        }

        function clearChat() {
            showConfirmDialog(
                '确认清空',
                '确定要清空所有聊天记录吗？这将无法恢复！',
                (confirmed) => {
                    if (confirmed) {
                        chatContainer.innerHTML = '';
                        conversationHistory = [];
                        messageElements.clear();

                        const sysPrompt = systemPrompt.value.trim();
                        if (sysPrompt) {
                            conversationHistory.push({ role: 'system', content: sysPrompt });
                        }

                        uploadedFiles = [];
                        uploadedFileUrls = [];
                        filePreview.innerHTML = '';
                        updateAttachmentIndicator();

                        saveConfig();
                        showStatus('聊天记录已清空', 'success');
                    }
                }
            );
        }

        function exportChat() {

            const exportHistory = conversationHistory.filter(msg => msg.role !== 'system');

            let exportContent = '# 聊天记录\n\n';
            exportHistory.forEach(msg => {
                const roleText = msg.role === 'user' ? '用户' : 'AI助手';

                let content = msg.content;
                if (msg.role === 'assistant') {

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = parseMarkdown(content);

                    const timestamps = tempDiv.querySelectorAll('.message-timestamp');
                    timestamps.forEach(el => el.remove());

                    content = tempDiv.textContent || tempDiv.innerText || content;
                }

                exportContent += '## ' + roleText + '\n\n' + content + '\n\n';
            });

            const blob = new Blob([exportContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = '聊天记录_' + timestamp + '.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus('聊天记录已导出', 'success');
        }

        function stopGeneration() {
            if (abortController) {
                abortController.abort();
                abortController = null;

                isGenerating = false;
                sendButton.disabled = false;
                sendButton.innerHTML = '发送';
                stopButton.style.display = 'none';

                showStatus('已停止生成', 'success');
            }
        }

        function prepareContext() {

            let context = [...conversationHistory];

            const maxContextLength = parseInt(contextLength.value);

            let systemMessages = context.filter(msg => msg.role === 'system');

            let conversationMessages = context.filter(msg => msg.role !== 'system');

            if (conversationMessages.length > maxContextLength) {
                conversationMessages = conversationMessages.slice(-maxContextLength);
            }

            context = [...systemMessages, ...conversationMessages];

            return context.map(({ role, content }) => ({ role, content }));
        }

        function handleAPIError(error, messageId, contentDiv) {

            if (error.name === 'AbortError') {
                for (let i = 0; i < conversationHistory.length; i++) {
                    if (conversationHistory[i].id === messageId) {
                        conversationHistory[i].content += "\n\n[已停止生成]";
                        contentDiv.innerHTML += "<p><em>[已停止生成]</em></p>";
                        break;
                    }
                }
                return;
            }

            console.error('Error:', error);
            contentDiv.innerHTML = '<p class="error">发生错误: ' + error.message + '</p>';

            const retryButton = document.createElement('button');
            retryButton.className = 'action-btn';
            retryButton.textContent = '重试';
            retryButton.style.marginTop = '10px';
            retryButton.addEventListener('click', () => {

                const userMessages = conversationHistory.filter(msg => msg.role === 'user');
                if (userMessages.length > 0) {
                    const lastUserMsg = userMessages[userMessages.length - 1];

                    deleteMessage(messageId);

                    sendAPIRequest(lastUserMsg.content);
                }
            });

            contentDiv.appendChild(retryButton);
            showStatus('请求失败: ' + error.message, 'error');
        }

        async function sendAPIRequest(userMessageContent, existingMessageId = null, existingContentDiv = null) {
            const apiKey = apiKeyInput.value.trim();
            const apiUrl = apiUrlInput.value.trim();

            if (!apiKey || !apiUrl) {
                showStatus('API配置不完整', 'error');
                return;
            }

            const apiMessages = prepareContext();

            let messageId = existingMessageId;
            let contentDiv = existingContentDiv;

            if (!messageId || !contentDiv) {
                const { contentDiv: newContentDiv, messageId: newMessageId } = addMessage('assistant', '');
                contentDiv = newContentDiv;
                messageId = newMessageId;
            }

            try {
                const isStream = streamCheckbox.checked;

                const requestBody = {
                    model: modelSelect.value,
                    messages: apiMessages,
                    temperature: parseFloat(tempSlider.value),
                    max_tokens: parseInt(maxTokens.value),
                    stream: isStream
                };

                abortController = new AbortController();

                if (isStream) {

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + apiKey
                        },
                        body: JSON.stringify(requestBody),
                        signal: abortController.signal
                    });

                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let assistantMessage = '';
                    let markdownContent = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') continue;

                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    assistantMessage += content;
                                    markdownContent = assistantMessage;

                                    contentDiv.innerHTML = parseMarkdown(markdownContent);
                                    processMessageContent(contentDiv);

                                    const direction = textDirectionSelect.value;
                                    if (direction === 'rtl') {
                                        contentDiv.classList.add('rtl');
                                    } else if (direction === 'auto' && detectTextDirection(assistantMessage) === 'rtl') {
                                        contentDiv.classList.add('rtl');
                                    } else {
                                        contentDiv.classList.remove('rtl');
                                    }

                                    if (!contentDiv.querySelector('.message-actions')) {
                                        const actionsDiv = document.createElement('div');
                                        actionsDiv.className = 'message-actions';

                                        const copyButton = document.createElement('button');
                                        copyButton.className = 'action-btn';
                                        copyButton.textContent = '复制';
                                        copyButton.addEventListener('click', (e) => {
                                            e.stopPropagation();

                                            const plainText = extractPlainText(contentDiv.innerHTML);

                                            navigator.clipboard.writeText(plainText)
                                                .then(() => showCopyToast())
                                                .catch(err => showStatus('复制失败', 'error'));
                                        });

                                        if ('speechSynthesis' in window) {
                                            const speakButton = document.createElement('button');
                                            speakButton.className = 'action-btn';
                                            speakButton.textContent = '朗读';
                                            speakButton.addEventListener('click', (e) => {
                                                e.stopPropagation();
                                                window.speechSynthesis.cancel();

                                                const plainText = extractPlainText(contentDiv.innerHTML);
                                                const utterance = new SpeechSynthesisUtterance(plainText);

                                                if (contentDiv.classList.contains('rtl')) {
                                                    utterance.lang = 'ar';
                                                }
                                                window.speechSynthesis.speak(utterance);
                                            });
                                            actionsDiv.appendChild(speakButton);
                                        }

                                        actionsDiv.appendChild(copyButton);
                                        contentDiv.appendChild(actionsDiv);

                                        const timestamp = document.createElement('div');
                                        timestamp.className = 'message-timestamp';
                                        timestamp.textContent = new Date().toLocaleTimeString();
                                        contentDiv.appendChild(timestamp);
                                    }

                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                } catch (e) {
                                    console.error('Parse error:', e);
                                }
                            }
                        }
                    }

                    for (let i = 0; i < conversationHistory.length; i++) {
                        if (conversationHistory[i].id === messageId) {
                            conversationHistory[i].content = assistantMessage;
                            break;
                        }
                    }

                } else {

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + apiKey
                        },
                        body: JSON.stringify(requestBody),
                        signal: abortController.signal
                    });

                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }

                    const data = await response.json();
                    const assistantMessage = data.choices[0].message.content;

                    contentDiv.innerHTML = parseMarkdown(assistantMessage);
                    processMessageContent(contentDiv);

                    const direction = textDirectionSelect.value;
                    if (direction === 'rtl') {
                        contentDiv.classList.add('rtl');
                    } else if (direction === 'auto' && detectTextDirection(assistantMessage) === 'rtl') {
                        contentDiv.classList.add('rtl');
                    } else {
                        contentDiv.classList.remove('rtl');
                    }

                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'message-actions';

                    const copyButton = document.createElement('button');
                    copyButton.className = 'action-btn';
                    copyButton.textContent = '复制';
                    copyButton.addEventListener('click', (e) => {
                        e.stopPropagation();

                        const plainText = extractPlainText(contentDiv.innerHTML);

                        navigator.clipboard.writeText(plainText)
                            .then(() => showCopyToast())
                            .catch(err => showStatus('复制失败', 'error'));
                    });

                    if ('speechSynthesis' in window) {
                        const speakButton = document.createElement('button');
                        speakButton.className = 'action-btn';
                        speakButton.textContent = '朗读';
                        speakButton.addEventListener('click', (e) => {
                            e.stopPropagation();
                            window.speechSynthesis.cancel();

                            const plainText = extractPlainText(contentDiv.innerHTML);
                            const utterance = new SpeechSynthesisUtterance(plainText);

                            if (contentDiv.classList.contains('rtl')) {
                                utterance.lang = 'ar';
                            }
                            window.speechSynthesis.speak(utterance);
                        });
                        actionsDiv.appendChild(speakButton);
                    }

                    actionsDiv.appendChild(copyButton);
                    contentDiv.appendChild(actionsDiv);

                    const timestamp = document.createElement('div');
                    timestamp.className = 'message-timestamp';
                    timestamp.textContent = new Date().toLocaleTimeString();
                    contentDiv.appendChild(timestamp);

                    for (let i = 0; i < conversationHistory.length; i++) {
                        if (conversationHistory[i].id === messageId) {
                            conversationHistory[i].content = assistantMessage;
                            break;
                        }
                    }
                }

                saveConfig();

                return true;
            } catch (error) {
                handleAPIError(error, messageId, contentDiv);
                return false;
            }
        }

        async function sendMessage() {
            const message = messageInput.value.trim();

            if (!message && uploadedFileUrls.length === 0) return;

            const apiKey = apiKeyInput.value.trim();
            const apiUrl = apiUrlInput.value.trim();

            if (!apiKey) {
                showStatus('请输入API Key', 'error');
                return;
            }

            if (!apiUrl) {
                showStatus('请输入API地址', 'error');
                return;
            }

            saveConfig();

            if (currentEditingMessageId) {

                const messageIndex = conversationHistory.findIndex(msg => msg.id === currentEditingMessageId);
                if (messageIndex !== -1) {

                    const messageElement = messageElements.get(currentEditingMessageId);
                    if (messageElement) {

                        const contentDiv = messageElement.querySelector('.message-content');
                        contentDiv.textContent = message;

                        conversationHistory[messageIndex].content = message;

                        currentEditingMessageId = null;
                        sendButton.textContent = '发送';

                        messageInput.value = '';
                        messageInput.style.height = 'auto';

                        saveConfig();

                        showStatus('消息已更新', 'success');
                        return;
                    }
                }
            }

            isGenerating = true;
            messageInput.value = '';
            messageInput.style.height = 'auto';
            sendButton.disabled = true;
            sendButton.innerHTML = '生成中<span class="loading active"></span>';
            stopButton.style.display = 'inline-block';

            let userMessageContent = message;
            let fileUrlsText = '';
            let apiMessageContent = message;

            if (uploadedFileUrls.length > 0) {

                fileUrlsText = uploadedFileUrls.map(fileObj => fileObj.url).join(' ') + ' ';

                const fileNames = uploadedFileUrls.map(fileObj => fileObj.filename).join(', ');

                userMessageContent = message + (message ? '\n\n' : '') + '[附件: ' + fileNames + ']';

                apiMessageContent = fileUrlsText + message;
            }

            const userMessageId = addMessage('user', userMessageContent, apiMessageContent).messageId;

            const sysPrompt = systemPrompt.value.trim();

            let hasSystemMsg = false;
            for (let i = 0; i < conversationHistory.length; i++) {
                if (conversationHistory[i].role === 'system') {
                    if (sysPrompt) {
                        conversationHistory[i].content = sysPrompt;
                    } else {
                        conversationHistory.splice(i, 1);
                    }
                    hasSystemMsg = true;
                    break;
                }
            }

            if (!hasSystemMsg && sysPrompt) {
                conversationHistory.unshift({ role: 'system', content: sysPrompt });
            }

            const userMessageIndex = conversationHistory.findIndex(msg => msg.id === userMessageId);
            if (userMessageIndex !== -1) {
                conversationHistory[userMessageIndex].content = apiMessageContent;
            }

            await sendAPIRequest(apiMessageContent);

            isGenerating = false;
            sendButton.disabled = false;
            sendButton.innerHTML = '发送';
            stopButton.style.display = 'none';
            abortController = null;
            messageInput.focus();

            uploadedFiles = [];
            uploadedFileUrls = [];
            filePreview.innerHTML = '';
            updateAttachmentIndicator();

            fileUploadContainer.classList.remove('active');
        }

        tempSlider.addEventListener('input', (e) => {
            tempValue.textContent = e.target.value;
        });

        if (sendButton) sendButton.addEventListener('click', sendMessage);
        if (stopButton) stopButton.addEventListener('click', stopGeneration);
        if (clearButton) clearButton.addEventListener('click', clearChat);
        if (exportButton) exportButton.addEventListener('click', exportChat);

        if (messageInput) {
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && !isGenerating) {
                    e.preventDefault();
                    sendMessage();
                }

            });
        }

        if (highlightYellow) {
            highlightYellow.addEventListener('click', () => highlightText('yellow'));
        }

        if (highlightGreen) {
            highlightGreen.addEventListener('click', () => highlightText('green'));
        }

        if (highlightBlue) {
            highlightBlue.addEventListener('click', () => highlightText('blue'));
        }

        if (highlightPink) {
            highlightPink.addEventListener('click', () => highlightText('pink'));
        }

        if (removeHighlight) {
            removeHighlight.addEventListener('click', removeHighlightFromSelection);
        }

        if (closeNoteEditor) {
            closeNoteEditor.addEventListener('click', hideNoteEditor);
        }

        if (cancelNote) {
            cancelNote.addEventListener('click', hideNoteEditor);
        }

        if (saveNote) {
            saveNote.addEventListener('click', saveNoteToStorage);
        }

        function initTextHighlighting() {
            document.addEventListener('mouseup', handleTextSelection);
            document.addEventListener('selectionchange', handleSelectionChange);
        }

        function handleTextSelection(e) {

            if (!isTextSelectionMode) {
                console.log('📝 文本选择被忽略：模式未激活');
                return;
            }

            if (isScreenshotMode) {
                console.log('📝 文本选择被忽略：截图模式激活');
                return;
            }

            const selection = window.getSelection();
            console.log('📝 文本选择事件:', {
                selectionText: selection.toString(),
                rangeCount: selection.rangeCount,
                event: e.target
            });

            if (selection.toString().trim().length > 0) {

                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                const pdfTextLayer = document.getElementById('pdfTextLayer');
                const pdfViewerContainer = document.getElementById('pdfViewerContainer');

                let isInPDFArea = false;
                if (pdfTextLayer || pdfViewerContainer) {
                    const element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;

                    if (pdfTextLayer && (pdfTextLayer.contains(element) || element === pdfTextLayer)) {
                        isInPDFArea = true;
                        console.log('📝 选择在PDF文本层内');
                    }

                    else if (pdfViewerContainer && (pdfViewerContainer.contains(element) || element === pdfViewerContainer)) {
                        isInPDFArea = true;
                        console.log('📝 选择在PDF容器内');
                    }
                }

                if (isInPDFArea) {
                    currentSelectedText = selection.toString().trim();
                    currentSelection = selection;
                    showHighlightToolbar(e.pageX, e.pageY);
                    console.log('📝 PDF文本已选择:', currentSelectedText.substring(0, 50) + '...');
                } else {
                    console.log('📝 选择不在PDF区域内');
                    hideHighlightToolbar();
                }
            } else {
                hideHighlightToolbar();
            }
        }

        function handleSelectionChange() {
            const selection = window.getSelection();
            if (selection.toString().trim().length === 0) {
                hideHighlightToolbar();
            }
        }

        function showHighlightToolbar(x, y) {
            highlightToolbar.style.left = x + 'px';
            highlightToolbar.style.top = (y - 40) + 'px';
            highlightToolbar.style.display = 'block';

            showSelectionFeedback();
        }

        function showSelectionFeedback() {

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect();

                let selectionIndicator = document.getElementById('selectionIndicator');
                if (!selectionIndicator) {
                    selectionIndicator = document.createElement('div');
                    selectionIndicator.id = 'selectionIndicator';
                    selectionIndicator.style.cssText = 'position: fixed; background: rgba(0, 123, 255, 0.2); border: 2px solid rgba(0, 123, 255, 0.5); pointer-events: none; z-index: 9999; border-radius: 3px;';
                    document.body.appendChild(selectionIndicator);
                }

                selectionIndicator.style.left = rect.left + 'px';
                selectionIndicator.style.top = rect.top + 'px';
                selectionIndicator.style.width = rect.width + 'px';
                selectionIndicator.style.height = rect.height + 'px';
                selectionIndicator.style.display = 'block';
            }
        }

        function hideHighlightToolbar() {
            highlightToolbar.style.display = 'none';

            const selectionIndicator = document.getElementById('selectionIndicator');
            if (selectionIndicator) {
                selectionIndicator.style.display = 'none';
            }
        }

        function highlightText(color) {
            if (!currentSelection || currentSelectedText.length === 0) return;

            try {
                const range = currentSelection.getRangeAt(0);

                if (range.startContainer !== range.endContainer) {
                    showStatus('请选择单个文本块进行高亮', 'warning');
                    return;
                }

                if (range.startContainer.nodeType !== Node.TEXT_NODE) {
                    showStatus('请选择文本内容进行高亮', 'warning');
                    return;
                }

                const span = document.createElement('span');
                span.className = 'highlight-' + color;
                span.setAttribute('data-highlight-id', Date.now());
                span.setAttribute('data-highlight-color', color);

                try {

                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                } catch (surroundError) {

                    console.warn('使用替代高亮方法:', surroundError);
                    const selectedText = range.toString();
                    const textNode = document.createTextNode(selectedText);
                    span.appendChild(textNode);
                    range.deleteContents();
                    range.insertNode(span);
                }

                highlightedTexts.push({
                    id: span.getAttribute('data-highlight-id'),
                    text: currentSelectedText,
                    color: color,
                    timestamp: new Date().toLocaleString(),
                    element: span
                });

                hideHighlightToolbar();
                currentSelection = null;
                currentSelectedText = '';

                showStatus('已添加' + color + '色高亮', 'success');

                const shouldAddNote = confirm('是否要为此高亮添加笔记？');
                if (shouldAddNote) {
                    showNoteEditor(currentSelectedText);
                }

            } catch (error) {
                console.error('高亮失败:', error);
                showStatus('高亮失败，请重新选择文本', 'error');
            }
        }

        function removeHighlightFromSelection() {
            if (!currentSelection) return;

            try {
                const range = currentSelection.getRangeAt(0);
                const container = range.commonAncestorContainer;

                let highlightElement = container.nodeType === Node.TEXT_NODE ?
                    container.parentElement : container;

                while (highlightElement && !highlightElement.className.includes('highlight-')) {
                    highlightElement = highlightElement.parentElement;
                }

                if (highlightElement && highlightElement.className.includes('highlight-')) {
                    const highlightId = highlightElement.getAttribute('data-highlight-id');

                    highlightedTexts = highlightedTexts.filter(h => h.id !== highlightId);

                    const parent = highlightElement.parentNode;
                    while (highlightElement.firstChild) {
                        parent.insertBefore(highlightElement.firstChild, highlightElement);
                    }
                    parent.removeChild(highlightElement);

                    showStatus('已移除高亮', 'success');
                }

                hideHighlightToolbar();

            } catch (error) {
                console.error('移除高亮失败:', error);
                showStatus('移除高亮失败', 'error');
            }
        }

        function showNoteEditor(selectedText = '') {
            noteTitle.value = '';
            noteContent.value = selectedText;
            noteTags.value = '';
            noteEditor.style.display = 'block';
        }

        function hideNoteEditor() {
            noteEditor.style.display = 'none';
        }

        function saveNoteToStorage() {
            const title = noteTitle.value.trim();
            const content = noteContent.value.trim();
            const tags = noteTags.value.trim();

            if (!title || !content) {
                showStatus('请填写笔记标题和内容', 'error');
                return;
            }

            const note = {
                id: Date.now(),
                title: title,
                content: content,
                tags: tags.split(',').map(tag => tag.trim()).filter(tag => tag),
                timestamp: new Date().toLocaleString(),
                selectedText: currentSelectedText
            };

            savedNotes.push(note);
            hideNoteEditor();
            showStatus('笔记已保存', 'success');

            const shouldSendToChat = confirm('是否将笔记内容发送到聊天中进行进一步分析？');
            if (shouldSendToChat) {
                const prompt = '我刚刚记录了一条笔记，请帮我分析和扩展：\n\n标题：' + title + '\n内容：' + content + '\n标签：' + tags + '\n\n原文选段：' + currentSelectedText;
                messageInput.value = prompt;
                sendMessage();
            }
        }

        function showCitationEditor() {
            citationEditor.style.display = 'block';
            citationOutput.textContent = '格式化后的引用将显示在这里...';
        }

        function hideCitationEditor() {
            citationEditor.style.display = 'none';
        }

        function formatCitationText() {
            const format = citationFormat.value;
            const input = citationInput.value.trim();

            if (!input) {
                showStatus('请输入引用信息', 'error');
                return;
            }

            let formattedCitation = '';

            switch (format) {
                case 'apa':
                    formattedCitation = formatAPACitation(input);
                    break;
                case 'mla':
                    formattedCitation = formatMLACitation(input);
                    break;
                case 'chicago':
                    formattedCitation = formatChicagoCitation(input);
                    break;
                case 'ieee':
                    formattedCitation = formatIEEECitation(input);
                    break;
                case 'harvard':
                    formattedCitation = formatHarvardCitation(input);
                    break;
                case 'vancouver':
                    formattedCitation = formatVancouverCitation(input);
                    break;
                default:
                    formattedCitation = input;
            }

            citationOutput.textContent = formattedCitation;
        }

        function formatAPACitation(input) {
            return 'APA格式: ' + input;
        }

        function formatMLACitation(input) {
            return 'MLA格式: ' + input;
        }

        function formatChicagoCitation(input) {
            return 'Chicago格式: ' + input;
        }

        function formatIEEECitation(input) {
            return 'IEEE格式: ' + input;
        }

        function formatHarvardCitation(input) {
            return 'Harvard格式: ' + input;
        }

        function formatVancouverCitation(input) {
            return 'Vancouver格式: ' + input;
        }

        function copyCitationToClipboard() {
            const citation = citationOutput.textContent;
            if (citation && citation !== '格式化后的引用将显示在这里...') {
                navigator.clipboard.writeText(citation).then(() => {
                    showStatus('引用已复制到剪贴板', 'success');
                }).catch(() => {
                    showStatus('复制失败，请手动复制', 'error');
                });
            }
        }

        function initEnhancedLiteratureTools() {

            setTimeout(() => {
                initTextHighlighting();

                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'n') {
                        e.preventDefault();
                        const selectedText = window.getSelection().toString().trim();
                        showNoteEditor(selectedText);
                    }
                });

                if (pdfCanvas) {
                    initPDFSelection();
                }
            }, 100);
        }

        textDirectionSelect.addEventListener('change', () => {
            const direction = textDirectionSelect.value;

            document.querySelectorAll('.message-content').forEach(element => {
                if (direction === 'rtl') {
                    element.classList.add('rtl');
                } else if (direction === 'ltr') {
                    element.classList.remove('rtl');
                } else {

                    const content = element.textContent;
                    if (detectTextDirection(content) === 'rtl') {
                        element.classList.add('rtl');
                    } else {
                        element.classList.remove('rtl');
                    }
                }
            });
            saveConfig();
        });

        function initialize() {
            try {
                console.log('🚀 智能学术助手初始化开始...');

                const hwCapabilities = HardwareCapabilities.detect();
                const hwSettings = hwCapabilities.getOptimalRenderSettings();

                console.log('硬件优化设置:', hwSettings);

                if (!hwCapabilities.hasGPU) {
                    console.warn('软件渲染模式：PDF预览性能可能受限');
                    setTimeout(() => {
                        showStatus('检测到软件渲染模式，PDF预览性能可能受限', 'info');
                    }, 2000);
                } else if (hwCapabilities.hasGPU && hwCapabilities.hasWebGL) {
                    console.log('硬件加速已启用：PDF预览性能已优化');
                    setTimeout(() => {
                        showStatus('检测到硬件加速支持，PDF预览性能已优化', 'success');
                    }, 2000);
                }

                initializeLibraries();
                loadConfig();
                if (messageInput) messageInput.focus();
                initEnhancedLiteratureTools();

                console.log('✅ 智能学术助手初始化完成');
                showStatus('智能学术助手已就绪', 'success');
            } catch (error) {
                console.error('❌ 初始化失败:', error);
                showStatus('初始化失败: ' + error.message, 'error');
            }
        }

        window.addEventListener('error', function(e) {

            const errorSource = e.filename || e.source || '';
            const errorMessage = e.message || '';

            const ignoredErrors = [
                'gator.volces.com',
                'share-modal.js',
                'chrome-extension://',
                'moz-extension://',
                'ERR_BLOCKED_BY_CLIENT',
                'Non-Error promise rejection captured',
                'ResizeObserver loop limit exceeded'
            ];

            const shouldIgnore = ignoredErrors.some(pattern =>
                errorSource.includes(pattern) || errorMessage.includes(pattern)
            );

            if (shouldIgnore) {

                return;
            }

            console.error('Global error:', e.error);

            if (e.error && e.error.message && e.error.message.includes('PDF')) {
                handlePDFError(e.error, 'Global Error Handler');
            } else if (errorSource.includes('znxs.html') || errorSource === '') {

                console.error('应用内部错误:', {
                    message: errorMessage,
                    source: errorSource,
                    line: e.lineno,
                    column: e.colno,
                    error: e.error
                });
                showStatus('应用程序发生错误，请刷新页面重试', 'error');
            }
        });

        window.addEventListener('unhandledrejection', function(e) {
            const reason = e.reason || '';
            const reasonStr = reason.toString ? reason.toString() : String(reason);

            if (reasonStr.includes('gator.volces.com') ||
                reasonStr.includes('ERR_BLOCKED_BY_CLIENT') ||
                reasonStr.includes('chrome-extension://') ||
                reasonStr.includes('share-modal.js')) {
                e.preventDefault();
                return;
            }

            console.error('未处理的Promise拒绝:', e.reason);
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e.reason);

            if (e.reason && e.reason.message && e.reason.message.includes('PDF')) {
                handlePDFError(e.reason, 'Promise Rejection Handler');
            } else {
                showStatus('操作失败，请重试', 'error');
            }
            e.preventDefault();
        });

        const PDFPerformanceMonitor = {
            renderTimes: [],
            loadTimes: [],

            recordRenderTime: function(startTime) {
                const endTime = performance.now();
                const renderTime = endTime - startTime;
                this.renderTimes.push(renderTime);

                if (this.renderTimes.length > 10) {
                    this.renderTimes.shift();
                }

                console.log(`PDF渲染耗时: ${renderTime.toFixed(2)}ms`);

                if (renderTime > 2000) {
                    showStatus('PDF渲染较慢，建议降低缩放比例以提高性能', 'warning');
                }
            },

            recordLoadTime: function(startTime) {
                const endTime = performance.now();
                const loadTime = endTime - startTime;
                this.loadTimes.push(loadTime);

                console.log(`PDF加载耗时: ${loadTime.toFixed(2)}ms`);
            },

            getAverageRenderTime: function() {
                if (this.renderTimes.length === 0) return 0;
                return this.renderTimes.reduce((a, b) => a + b, 0) / this.renderTimes.length;
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>

</html>


